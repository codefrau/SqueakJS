/* Smalltalk from Squeak4.5 with VMMaker 4.13.6 translated as JS source on 14 November 2014 12:21:50 am */
/* Automatically generated by
	JSSmartSyntaxPluginCodeGenerator VMMakerJS-bf.17 uuid: 399be48b-95d8-4722-bdcc-39a94a12c486
   from
	GeniePlugin VMMaker-bf.353 uuid: 8ae25e7e-8d2c-451e-8277-598b30e9c002
 */

(function GeniePlugin() {
"use strict";

var VM_PROXY_MAJOR = 1;
var VM_PROXY_MINOR = 11;

/*** Functions ***/
function CLASSOF(obj) { return typeof obj === "number" ? interpreterProxy.classSmallInteger() : obj.sqClass }
function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : 0 }
function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : 0 }
function DIV(a, b) { return Math.floor(a / b) | 0; }   // integer division
function MOD(a, b) { return a - DIV(a, b) * b | 0; }   // signed modulus
function SHL(a, b) { return b > 31 ? 0 : a << b; }     // fix JS shift
function SHR(a, b) { return b > 31 ? 0 : a >>> b; }    // fix JS shift
function SHIFT(a, b) { return b < 0 ? (b < -31 ? 0 : a >>> (0-b) ) : (b > 31 ? 0 : a << b); }
function PTR_ADD(p, n) { return new Int32Array(p.buffer, p.byteOffset + n * 4); }
function FPTR_ADD(p, n) { return new Float32Array(p.buffer, p.byteOffset + n * 4); }

/*** Variables ***/
var interpreterProxy = null;
var moduleName = "GeniePlugin v2.0 14 November 2014 (e)";



/*	arguments are pointer to ints paired as x,y coordinates of points */

function cSquaredDistanceFromto(aPoint, bPoint) {
	var aPointX;
	var bPointX;
	var xDiff;
	var aPointY;
	var bPointY;
	var yDiff;

	aPointX = aPoint[0];
	aPointY = aPoint[1];
	bPointX = bPoint[0];
	bPointY = bPoint[1];
	xDiff = bPointX - aPointX;
	yDiff = bPointY - aPointY;
	return (xDiff * xDiff) + (yDiff * yDiff);
}

function cSubstAngleFactorFromto(startDegreeNumber, endDegreeNumber) {
	var absDiff;

	absDiff = Math.abs(endDegreeNumber - startDegreeNumber);
	if (absDiff > 180) {
		absDiff = 360 - absDiff;
	}
	return (absDiff * absDiff) >>> 6;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

function getModuleName() {
	return moduleName;
}

function halt() {
	;
}

function majorNO() {
	return 2;
}

function minorNO() {
	return 0;
}

function msg(s) {
	console.log(moduleName + ": " + s);
}

function primSameClassAbsoluteStrokeDistanceMyPoints_otherPoints_myVectors_otherVectors_mySquaredLengths_otherSquaredLengths_myAngles_otherAngles_maxSizeAndReferenceFlag_rowBase_rowInsertRemove_rowInsertRemoveCount() {
	var otherAngles;
	var otherSquaredLengthsSize;
	var forReference;
	var jM1;
	var iM1;
	var jM1T2;
	var base;
	var insert;
	var otherVectors;
	var otherVectorsSize;
	var otherSquaredLengths;
	var rowBaseSize;
	var myPoints;
	var jLimiT;
	var mySquaredLengths;
	var additionalMultiInsertRemoveCost;
	var remove;
	var otherPoints;
	var otherPointsSize;
	var myVectors;
	var rowInsertRemoveCount;
	var rowBase;
	var maxDist;
	var iM1T2;
	var j;
	var insertRemove;
	var i;
	var myVectorsSize;
	var subst;
	var maxSize;
	var removeBase;
	var substBase;
	var myAngles;
	var insertRemoveCount;
	var rowInsertRemove;
	var insertBase;
	var myPointsOop;
	var otherPointsOop;
	var myVectorsOop;
	var otherVectorsOop;
	var mySquaredLengthsOop;
	var otherSquaredLengthsOop;
	var myAnglesOop;
	var otherAnglesOop;
	var maxSizeAndRefFlag;
	var rowBaseOop;
	var rowInsertRemoveOop;
	var rowInsertRemoveCountOop;
	var _return_value;

	myPointsOop = interpreterProxy.stackValue(11);
	otherPointsOop = interpreterProxy.stackValue(10);
	myVectorsOop = interpreterProxy.stackValue(9);
	otherVectorsOop = interpreterProxy.stackValue(8);
	mySquaredLengthsOop = interpreterProxy.stackValue(7);
	otherSquaredLengthsOop = interpreterProxy.stackValue(6);
	myAnglesOop = interpreterProxy.stackValue(5);
	otherAnglesOop = interpreterProxy.stackValue(4);
	maxSizeAndRefFlag = interpreterProxy.stackIntegerValue(3);
	rowBaseOop = interpreterProxy.stackValue(2);
	rowInsertRemoveOop = interpreterProxy.stackValue(1);
	rowInsertRemoveCountOop = interpreterProxy.stackValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (interpreterProxy.failed()) {
		msg("failed 1");
		return null;
	}
	interpreterProxy.success((((((((((interpreterProxy.isWords(myPointsOop) && interpreterProxy.isWords(otherPointsOop)) && interpreterProxy.isWords(myVectorsOop)) && interpreterProxy.isWords(otherVectorsOop)) && interpreterProxy.isWords(mySquaredLengthsOop)) && interpreterProxy.isWords(otherSquaredLengthsOop)) && interpreterProxy.isWords(myAnglesOop)) && interpreterProxy.isWords(otherAnglesOop)) && interpreterProxy.isWords(rowBaseOop)) && interpreterProxy.isWords(rowInsertRemoveOop)) && interpreterProxy.isWords(rowInsertRemoveCountOop));
	if (interpreterProxy.failed()) {
		msg("failed 2");
		return null;
	}
	interpreterProxy.success(interpreterProxy.isMemberOf(myPointsOop, "PointArray") && interpreterProxy.isMemberOf(otherPointsOop, "PointArray"));
	if (interpreterProxy.failed()) {
		msg("failed 3");
		return null;
	}
	myPoints = myPointsOop.wordsAsInt32Array();
	otherPoints = otherPointsOop.wordsAsInt32Array();
	myVectors = myVectorsOop.wordsAsInt32Array();
	otherVectors = otherVectorsOop.wordsAsInt32Array();
	mySquaredLengths = mySquaredLengthsOop.wordsAsInt32Array();
	otherSquaredLengths = otherSquaredLengthsOop.wordsAsInt32Array();
	myAngles = myAnglesOop.wordsAsInt32Array();
	otherAngles = otherAnglesOop.wordsAsInt32Array();
	rowBase = rowBaseOop.wordsAsInt32Array();
	rowInsertRemove = rowInsertRemoveOop.wordsAsInt32Array();

	/* Note: myPointsSize and mySquaredLengthsSize variables eliminated to reduce
	method temporary variable count for closure-enabled images */
	/* PointArrays */
	/* myPointsSize := (interpreterProxy stSizeOf: myPointsOop) bitShift: -1. */

	rowInsertRemoveCount = rowInsertRemoveCountOop.wordsAsInt32Array();
	otherPointsSize = SIZEOF(otherPointsOop) >>> 1;
	myVectorsSize = SIZEOF(myVectorsOop) >>> 1;

	/* IntegerArrays */
	/* mySquaredLengthsSize := interpreterProxy stSizeOf: mySquaredLengthsOop. */

	otherVectorsSize = SIZEOF(otherVectorsOop) >>> 1;
	otherSquaredLengthsSize = SIZEOF(otherSquaredLengthsOop);
	rowBaseSize = SIZEOF(rowBaseOop);
	interpreterProxy.success(((rowBaseSize === SIZEOF(rowInsertRemoveOop)) && (rowBaseSize === SIZEOF(rowInsertRemoveCountOop))) && (rowBaseSize > otherVectorsSize));
	if (interpreterProxy.failed()) {
		msg("failed 4");
		return null;
	}
	interpreterProxy.success((((((SIZEOF(mySquaredLengthsOop) >= (myVectorsSize - 1)) && ((SIZEOF(myPointsOop) >>> 1) >= myVectorsSize)) && (otherSquaredLengthsSize >= (otherVectorsSize - 1))) && (otherPointsSize >= otherVectorsSize)) && (SIZEOF(myAnglesOop) >= (myVectorsSize - 1))) && (SIZEOF(otherAnglesOop) >= (otherVectorsSize - 1)));
	if (interpreterProxy.failed()) {
		msg("failed 5");
		return null;
	}
	forReference = maxSizeAndRefFlag & 1;
	maxSize = maxSizeAndRefFlag >>> 1;
	maxDist = 1 << 29;
	if (forReference) {
		additionalMultiInsertRemoveCost = 0;
	} else {
		additionalMultiInsertRemoveCost = (maxSize * maxSize) >>> 10;
	}
	rowBase[0] = 0;
	rowInsertRemove[0] = 0;
	rowInsertRemoveCount[0] = 2;
	insertRemove = 0 - additionalMultiInsertRemoveCost;
	jLimiT = otherVectorsSize;
	if (!((otherPointsSize >= (jLimiT - 1)) && (otherSquaredLengthsSize >= (jLimiT - 1)))) {
		interpreterProxy.primitiveFail();
		return null;
	}
	for (j = 1; j <= jLimiT; j++) {
		jM1 = j - 1;
		insertRemove = (insertRemove + ((otherSquaredLengths[jM1] + cSquaredDistanceFromto(PTR_ADD(otherPoints, (jM1 << 1)), myPoints)) >>> 7)) + additionalMultiInsertRemoveCost;
		rowInsertRemove[j] = insertRemove;
		rowBase[j] = (insertRemove * j);
		rowInsertRemoveCount[j] = (j + 1);
	}
	insertRemove = rowInsertRemove[0] - additionalMultiInsertRemoveCost;
	for (i = 1; i <= myVectorsSize; i++) {
		iM1 = i - 1;
		iM1T2 = iM1 << 1;
		substBase = rowBase[0];
		insertRemove = (insertRemove + ((mySquaredLengths[iM1] + cSquaredDistanceFromto(PTR_ADD(myPoints, iM1T2), otherPoints)) >>> 7)) + additionalMultiInsertRemoveCost;
		rowInsertRemove[0] = insertRemove;
		rowBase[0] = (insertRemove * i);
		rowInsertRemoveCount[0] = (i + 1);
		jLimiT = otherVectorsSize;
		for (j = 1; j <= jLimiT; j++) {
			jM1 = j - 1;
			jM1T2 = jM1 << 1;
			removeBase = rowBase[j];
			insertBase = rowBase[jM1];
			remove = (mySquaredLengths[iM1] + cSquaredDistanceFromto(PTR_ADD(myPoints, iM1T2), PTR_ADD(otherPoints, (j << 1)))) >>> 7;
			if (((insertRemove = rowInsertRemove[j])) === 0) {
				removeBase += remove;
			} else {
				removeBase = (removeBase + insertRemove) + (remove * rowInsertRemoveCount[j]);
				remove += insertRemove;
			}
			insert = (otherSquaredLengths[jM1] + cSquaredDistanceFromto(PTR_ADD(otherPoints, jM1T2), PTR_ADD(myPoints, (i << 1)))) >>> 7;
			if (((insertRemove = rowInsertRemove[jM1])) === 0) {
				insertBase += insert;
			} else {
				insertBase = (insertBase + insertRemove) + (insert * rowInsertRemoveCount[jM1]);
				insert += insertRemove;
			}
			if (forReference) {
				substBase = maxDist;
			} else {
				subst = ((cSquaredDistanceFromto(PTR_ADD(otherVectors, jM1T2), PTR_ADD(myVectors, iM1T2)) + cSquaredDistanceFromto(PTR_ADD(otherPoints, jM1T2), PTR_ADD(myPoints, iM1T2))) * (16 + cSubstAngleFactorFromto(otherAngles[jM1], myAngles[iM1]))) >>> 11;
				substBase += subst;
			}
			if ((substBase <= removeBase) && (substBase <= insertBase)) {
				base = substBase;
				insertRemove = 0;
				insertRemoveCount = 1;
			} else {
				if (removeBase <= insertBase) {
					base = removeBase;
					insertRemove = remove + additionalMultiInsertRemoveCost;
					insertRemoveCount = rowInsertRemoveCount[j] + 1;
				} else {
					base = insertBase;
					insertRemove = insert + additionalMultiInsertRemoveCost;
					insertRemoveCount = rowInsertRemoveCount[jM1] + 1;
				}
			}
			substBase = rowBase[j];
			rowBase[j] = Math.min(base, maxDist);
			rowInsertRemove[j] = Math.min(insertRemove, maxDist);
			rowInsertRemoveCount[j] = insertRemoveCount;
		}
		insertRemove = rowInsertRemove[0];
	}
	_return_value = base;
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.popthenPush(13, _return_value);
	return null;
}


/*	majorNO * 1000 + minorNO */

function primVersionNO() {
	var _return_value;

	_return_value = ((majorNO() * 1000) + minorNO());
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.popthenPush(1, _return_value);
	return null;
}


/*	Note: This is coded so that is can be run from Squeak. */

function setInterpreter(anInterpreter) {
	var ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy.majorVersion() == VM_PROXY_MAJOR;
	if (ok === false) {
		return false;
	}
	ok = interpreterProxy.minorVersion() >= VM_PROXY_MINOR;
	return ok;
}


function registerPlugin() {
	if (typeof Squeak === "object" && Squeak.registerExternalModule) {
		Squeak.registerExternalModule("GeniePlugin", {
			primVersionNO: primVersionNO,
			setInterpreter: setInterpreter,
			primSameClassAbsoluteStrokeDistanceMyPoints_otherPoints_myVectors_otherVectors_mySquaredLengths_otherSquaredLengths_myAngles_otherAngles_maxSizeAndReferenceFlag_rowBase_rowInsertRemove_rowInsertRemoveCount: primSameClassAbsoluteStrokeDistanceMyPoints_otherPoints_myVectors_otherVectors_mySquaredLengths_otherSquaredLengths_myAngles_otherAngles_maxSizeAndReferenceFlag_rowBase_rowInsertRemove_rowInsertRemoveCount,
			getModuleName: getModuleName,
		});
	} else self.setTimeout(registerPlugin, 100);
}

registerPlugin();

})(); // Register module/plugin
