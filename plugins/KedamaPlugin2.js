/* Smalltalk from Squeak4.5 with VMMaker 4.13.6 translated as JS source on 13 November 2014 7:11:01 pm */
/* Automatically generated by
	JSPluginCodeGenerator VMMakerJS-bf.16 uuid: aa9fd3da-7901-4c62-ae34-c166f1492d3b
   from
	KedamaPlugin2 Kedama-Plugins-yo.1 uuid: 3fc7d691-0149-ba4d-a339-5d27cd44a2f8
 */

(function KedamaPlugin2() {
"use strict";

var VM_PROXY_MAJOR = 1;
var VM_PROXY_MINOR = 11;

/*** Functions ***/
function CLASSOF(obj) { return typeof obj === "number" ? interpreterProxy.classSmallInteger() : obj.sqClass }
function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : 0 }
function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : 0 }
function DIV(a, b) { return Math.floor(a / b) | 0; }   // integer division
function MOD(a, b) { return a - DIV(a, b) * b | 0; }   // signed modulus
function SHL(a, b) { return b > 31 ? 0 : a << b; }     // fix JS shift
function SHR(a, b) { return b > 31 ? 0 : a >>> b; }    // fix JS shift
function SHIFT(a, b) { return b < 0 ? (b < -31 ? 0 : a >>> (0-b) ) : (b > 31 ? 0 : a << b); }

/*** Variables ***/
var interpreterProxy = null;
var kedamaRandomSeed = 0;
var moduleName = "KedamaPlugin2 13 November 2014 (e)";
var randA = 0;
var randM = 0;
var randQ = 0;
var randR = 0;


function degreesFromXy(x, y) {
	var tanVal;
	var theta;

	/* inline: true */;
	if (x === 0.0) {
		if (y >= 0.0) {
			return 90.0;
		} else {
			return 270.0;
		}
	} else {
		tanVal = y / x;
		theta = Math.atan(tanVal);
		if (x >= 0.0) {
			if (y >= 0.0) {
				return theta / 0.0174532925199433;
			} else {
				return 360.0 + (theta / 0.0174532925199433);
			}
		} else {
			return 180.0 + (theta / 0.0174532925199433);
		}
	}
	return 0.0;
}

function degreesToRadians(degrees) {
	var deg;
	var headingRadians;
	var q;

	/* inline: true */;
	deg = 90.0 - degrees;
	q = deg / 360.0|0;
	if (deg < 0.0) {
		--q;
	}
	headingRadians = (deg - (q * 360.0)) * 0.0174532925199433;
	return headingRadians;
}

function drawTurtlesInArray() {
	var bitsIndex;
	var colorArray;
	var colorOop;
	var destBits;
	var destHeight;
	var destOop;
	var destWidth;
	var i;
	var size;
	var visible;
	var visibleArray;
	var visibleOop;
	var x;
	var xArray;
	var xOop;
	var y;
	var yArray;
	var yOop;

	/* inline: true */;
	visibleOop = interpreterProxy.stackValue(0);
	colorOop = interpreterProxy.stackValue(1);
	yOop = interpreterProxy.stackValue(2);
	xOop = interpreterProxy.stackValue(3);
	destHeight = interpreterProxy.stackIntegerValue(4);
	destWidth = interpreterProxy.stackIntegerValue(5);
	destOop = interpreterProxy.stackValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(destOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(colorOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isBytes(visibleOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if ((destHeight * destWidth) !== SIZEOF(destOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xOop);
	if (SIZEOF(yOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(colorOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(visibleOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xOop.wordsAsFloat32Array();
	yArray = yOop.wordsAsFloat32Array();
	colorArray = colorOop.words;
	visibleArray = visibleOop.bytes;
	destBits = destOop.words;
	for (i = 0; i <= (size - 1); i++) {
		x = (xArray[i]|0);
		;
		y = (yArray[i]|0);
		;
		visible = visibleArray[i];
		if ((visible !== 0) && (((x >= 0) && (y >= 0)) && ((x < destWidth) && (y < destHeight)))) {
			bitsIndex = (y * destWidth) + x;
			destBits[bitsIndex] = colorArray[i];
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(7);
}

function getHeadingArrayInto() {
	var heading;
	var headingArray;
	var headingOop;
	var i;
	var resultArray;
	var resultOop;
	var size;

	/* inline: true */;
	resultOop = interpreterProxy.stackValue(0);
	headingOop = interpreterProxy.stackValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(resultOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(headingOop);
	if (SIZEOF(resultOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	headingArray = headingOop.wordsAsFloat32Array();
	resultArray = resultOop.wordsAsFloat32Array();
	for (i = 0; i <= (size - 1); i++) {
		heading = headingArray[i];
		heading = heading / 0.0174532925199433;
		heading = 90.0 - heading;
		if (!(heading > 0.0)) {
			heading += 360.0;
		}
		resultArray[i] = heading;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(2);
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

function getModuleName() {
	return moduleName;
}

function getScalarHeading() {
	var heading;
	var headingArray;
	var headingOop;
	var index;

	/* inline: true */;
	headingOop = interpreterProxy.stackValue(0);
	index = interpreterProxy.stackIntegerValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) < index) {
		interpreterProxy.primitiveFail();
		return null;
	}
	headingArray = headingOop.wordsAsFloat32Array();
	heading = headingArray[index - 1];
	heading = radiansToDegrees(heading);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(3);
	interpreterProxy.pushFloat(heading);
}

function halt() {
	;
}

function initialiseModule() {
	kedamaRandomSeed = 17;

	/*  magic constant =      16807  */

	randA = 16807;

	/*  magic constant = 2147483647  */

	randM = 2147483647;
	randQ = DIV(randM, randA);
	randR = MOD(randM, randA);
}

function kedamaRandom2(range) {
	var hi;
	var lo;
	var r;
	var v;
	var val;

	/* inline: true */;
	if (range < 0) {
		r = 0 - range;
	} else {
		r = range;
	}
	hi = DIV(kedamaRandomSeed, randQ);
	lo = MOD(kedamaRandomSeed, randQ);
	kedamaRandomSeed = (randA * lo) - (randR * hi);
	v = kedamaRandomSeed & 65535;
	val = (v * (r + 1)) >>> 16;
	if (range < 0) {
		return 0 - val;
	} else {
		return val;
	}
}

function kedamaSetRandomSeed() {
	var seed;

	/* inline: true */;
	seed = interpreterProxy.stackIntegerValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	kedamaRandomSeed = seed & 65536;
	interpreterProxy.pop(1);
}

function makeMask() {
	var alpha;
	var dOrigin;
	var data;
	var dataBits;
	var dataSize;
	var highMask;
	var i;
	var mOrigin;
	var maskBits;
	var maskSize;
	var pixel;
	var shiftAmount;

	/* inline: true */;
	shiftAmount = interpreterProxy.stackIntegerValue(0);
	pixel = interpreterProxy.stackIntegerValue(1);
	maskBits = interpreterProxy.stackValue(2);
	dataBits = interpreterProxy.stackValue(3);
	if (interpreterProxy.failed()) {
		return null;
	}
	dataSize = SIZEOF(dataBits);
	maskSize = SIZEOF(maskBits);
	if (dataSize !== maskSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (shiftAmount < -32) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (shiftAmount > 8) {
		interpreterProxy.primitiveFail();
		return null;
	}
	dOrigin = dataBits.words;
	mOrigin = maskBits.words;
	highMask = 4278190080;
	for (i = 0; i <= (dataSize - 1); i++) {
		data = dOrigin[i];
		alpha = SHIFT(data, shiftAmount);
		if (alpha > 255) {
			alpha = 255;
		}
		if (alpha < 0) {
			alpha = 0;
		}
		mOrigin[i] = (((alpha << 24) & highMask) | pixel);
	}
	interpreterProxy.pop(4);
}

function makeMaskLog() {
	var alpha;
	var dOrigin;
	var data;
	var dataBits;
	var dataSize;
	var highMask;
	var i;
	var mOrigin;
	var maskBits;
	var maskSize;
	var max;
	var maxFirst;
	var maxLog;
	var maxOop;
	var pixel;

	/* inline: true */;
	maxOop = interpreterProxy.stackValue(0);
	pixel = interpreterProxy.stackIntegerValue(1);
	maskBits = interpreterProxy.stackValue(2);
	dataBits = interpreterProxy.stackValue(3);
	if (interpreterProxy.failed()) {
		return null;
	}
	maxFirst = maxOop.words;
	max = maxFirst[0];
	if (interpreterProxy.failed()) {
		return null;
	}
	maxLog = Math.log(max);
	dataSize = SIZEOF(dataBits);
	maskSize = SIZEOF(maskBits);
	if (dataSize !== maskSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	dOrigin = dataBits.words;
	mOrigin = maskBits.words;
	highMask = 4278190080;
	for (i = 0; i <= (dataSize - 1); i++) {
		data = dOrigin[i];
		if (data === 0) {
			alpha = 0;
		} else {
			alpha = (((255.0 / maxLog) * Math.log(data))|0);
		}
		if (alpha > 255) {
			alpha = 255;
		}
		mOrigin[i] = (((alpha << 24) & highMask) | pixel);
	}
	interpreterProxy.pop(4);
}

function makeTurtlesMap() {
	var height;
	var index;
	var map;
	var mapIndex;
	var mapOop;
	var size;
	var whoArray;
	var whoOop;
	var width;
	var x;
	var xArray;
	var xOop;
	var y;
	var yArray;
	var yOop;

	/* inline: true */;
	height = interpreterProxy.stackIntegerValue(0);
	width = interpreterProxy.stackIntegerValue(1);
	yOop = interpreterProxy.stackValue(2);
	xOop = interpreterProxy.stackValue(3);
	whoOop = interpreterProxy.stackValue(4);
	mapOop = interpreterProxy.stackValue(5);
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(whoOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(mapOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(whoOop);
	if (SIZEOF(xOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(yOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(mapOop) !== (height * width)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xOop.wordsAsFloat32Array();
	yArray = yOop.wordsAsFloat32Array();
	whoArray = whoOop.words;
	map = mapOop.words;
	for (index = 0; index <= ((height * width) - 1); index++) {
		map[index] = 0;
	}
	for (index = 0; index <= (size - 1); index++) {
		x = xArray[index];
		y = yArray[index];
		mapIndex = (width * y) + x;
		if ((mapIndex >= 0) && (mapIndex < (height * width))) {
			map[mapIndex] = whoArray[index];
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
}

function primPixelAtXY() {
	var bits;
	var bitsOop;
	var height;
	var index;
	var ret;
	var width;
	var x;
	var xPos;
	var y;
	var yPos;

	/* inline: true */;
	height = interpreterProxy.stackIntegerValue(0);
	width = interpreterProxy.stackIntegerValue(1);
	yPos = interpreterProxy.stackFloatValue(2);
	xPos = interpreterProxy.stackFloatValue(3);
	bitsOop = interpreterProxy.stackValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(bitsOop) !== (height * width)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	x = xPos|0;
	y = yPos|0;
	bits = bitsOop.words;
	if ((((x >= 0) && (x < width)) && (y >= 0)) && (y < height)) {
		index = (y * width) + x;
		ret = bits[index];
	} else {
		ret = 0;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
	interpreterProxy.pushInteger(ret);
}

function primPixelAtXYPut() {
	var bits;
	var bitsOop;
	var height;
	var index;
	var v;
	var value;
	var width;
	var x;
	var xPos;
	var y;
	var yPos;

	/* inline: true */;
	height = interpreterProxy.stackIntegerValue(0);
	width = interpreterProxy.stackIntegerValue(1);
	value = interpreterProxy.stackIntegerValue(2);
	yPos = interpreterProxy.stackFloatValue(3);
	xPos = interpreterProxy.stackFloatValue(4);
	bitsOop = interpreterProxy.stackValue(5);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(bitsOop) !== (height * width)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	x = xPos|0;
	y = yPos|0;
	v = value;
	if (v > 1073741823) {
		v = 1073741823;
	}
	if (v < 0) {
		v = 0;
	}
	bits = bitsOop.words;
	if ((((x >= 0) && (x < width)) && (y >= 0)) && (y < height)) {
		index = (y * width) + x;
		bits[index] = v;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
}

function primPixelsAtXY() {
	var bits;
	var bitsHeight;
	var bitsIndex;
	var bitsOop;
	var bitsWidth;
	var destWords;
	var destWordsOop;
	var i;
	var size;
	var x;
	var xArray;
	var xArrayOop;
	var y;
	var yArray;
	var yArrayOop;

	/* inline: true */;
	destWordsOop = interpreterProxy.stackValue(0);
	bitsHeight = interpreterProxy.stackIntegerValue(1);
	bitsWidth = interpreterProxy.stackIntegerValue(2);
	bitsOop = interpreterProxy.stackValue(3);
	yArrayOop = interpreterProxy.stackValue(4);
	xArrayOop = interpreterProxy.stackValue(5);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(destWordsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if ((bitsHeight * bitsWidth) !== SIZEOF(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xArrayOop);
	if (SIZEOF(yArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(destWordsOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xArrayOop.wordsAsFloat32Array();
	yArray = yArrayOop.wordsAsFloat32Array();
	destWords = destWordsOop.words;
	bits = bitsOop.words;
	for (i = 0; i <= (size - 1); i++) {
		x = (xArray[i]|0);
		;
		y = (yArray[i]|0);
		;
		if (((x >= 0) && (y >= 0)) && ((x < bitsWidth) && (y < bitsHeight))) {
			bitsIndex = (y * bitsWidth) + x;
			destWords[i] = bits[bitsIndex];
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
}

function primScalarForward() {
	var bottomEdgeMode;
	var destHeight;
	var destWidth;
	var dist;
	var headingArray;
	var headingOop;
	var i;
	var index;
	var leftEdgeMode;
	var newX;
	var newY;
	var rightEdgeMode;
	var size;
	var topEdgeMode;
	var val;
	var xArray;
	var xOop;
	var yArray;
	var yOop;

	/* inline: true */;
	bottomEdgeMode = interpreterProxy.stackIntegerValue(0);
	topEdgeMode = interpreterProxy.stackIntegerValue(1);
	rightEdgeMode = interpreterProxy.stackIntegerValue(2);
	leftEdgeMode = interpreterProxy.stackIntegerValue(3);
	destHeight = interpreterProxy.stackFloatValue(4);
	destWidth = interpreterProxy.stackFloatValue(5);
	val = interpreterProxy.stackFloatValue(6);
	headingOop = interpreterProxy.stackValue(7);
	yOop = interpreterProxy.stackValue(8);
	xOop = interpreterProxy.stackValue(9);
	index = interpreterProxy.stackIntegerValue(10);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xOop);
	if (SIZEOF(yOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xOop.wordsAsFloat32Array();
	yArray = yOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	dist = val;
	i = index - 1;
	newX = xArray[i] + (dist * Math.cos(headingArray[i]));
	newY = yArray[i] - (dist * Math.sin(headingArray[i]));
	scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(i, xArray, headingArray, newX, destWidth, leftEdgeMode, rightEdgeMode);
	scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(i, yArray, headingArray, newY, destHeight, topEdgeMode, bottomEdgeMode);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(11);
}

function primSetPixelsAtXY() {
	var bits;
	var bitsHeight;
	var bitsIndex;
	var bitsOop;
	var bitsWidth;
	var floatsValue;
	var fv;
	var i;
	var intValue;
	var isValueInt;
	var isValueWordArray;
	var pArray;
	var pArrayOop;
	var size;
	var value;
	var valueOop;
	var wordsValue;
	var x;
	var xArray;
	var xArrayOop;
	var y;
	var yArray;
	var yArrayOop;

	/* inline: true */;
	valueOop = interpreterProxy.stackValue(0);
	bitsHeight = interpreterProxy.stackIntegerValue(1);
	bitsWidth = interpreterProxy.stackIntegerValue(2);
	bitsOop = interpreterProxy.stackValue(3);
	yArrayOop = interpreterProxy.stackValue(4);
	xArrayOop = interpreterProxy.stackValue(5);
	pArrayOop = interpreterProxy.stackValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(pArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if ((bitsHeight * bitsWidth) !== SIZEOF(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xArrayOop);
	if (SIZEOF(pArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(yArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	pArray = pArrayOop.bytes;
	xArray = xArrayOop.wordsAsFloat32Array();
	yArray = yArrayOop.wordsAsFloat32Array();
	isValueInt = typeof valueOop === "number";
	if (isValueInt) {
		intValue = valueOop;
		value = intValue;
	} else {
		if (SIZEOF(valueOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
		isValueWordArray = interpreterProxy.isMemberOf(valueOop, "WordArray");
		if (isValueWordArray) {
			wordsValue = valueOop.words;
		} else {
			floatsValue = valueOop.wordsAsFloat32Array();
		}
	}
	bits = bitsOop.words;
	for (i = 0; i <= (size - 1); i++) {
		if (pArray[i] === 1) {
			x = (xArray[i]|0);
			;
			y = (yArray[i]|0);
			;
			if (((x >= 0) && (y >= 0)) && ((x < bitsWidth) && (y < bitsHeight))) {
				bitsIndex = (y * bitsWidth) + x;
				if (isValueInt) {
					bits[bitsIndex] = value;
				} else {
					if (isValueWordArray) {
						bits[bitsIndex] = wordsValue[i];
					} else {
						fv = floatsValue[i];
						;
						bits[bitsIndex] = fv;
					}
				}
			}
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(7);
}

function primTurtlesForward() {
	var bottomEdgeMode;
	var destHeight;
	var destWidth;
	var dist;
	var headingArray;
	var headingOop;
	var i;
	var isValVector;
	var leftEdgeMode;
	var newX;
	var newY;
	var pArray;
	var pOop;
	var rightEdgeMode;
	var size;
	var topEdgeMode;
	var val;
	var valArray;
	var valOop;
	var xArray;
	var xOop;
	var yArray;
	var yOop;

	/* inline: true */;
	bottomEdgeMode = interpreterProxy.stackIntegerValue(0);
	topEdgeMode = interpreterProxy.stackIntegerValue(1);
	rightEdgeMode = interpreterProxy.stackIntegerValue(2);
	leftEdgeMode = interpreterProxy.stackIntegerValue(3);
	destHeight = interpreterProxy.stackFloatValue(4);
	destWidth = interpreterProxy.stackFloatValue(5);
	valOop = interpreterProxy.stackValue(6);
	headingOop = interpreterProxy.stackValue(7);
	yOop = interpreterProxy.stackValue(8);
	xOop = interpreterProxy.stackValue(9);
	pOop = interpreterProxy.stackValue(10);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(pOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (valOop.isFloat) {
		isValVector = false;
	} else {
		if (interpreterProxy.isWords(valOop)) {
			isValVector = true;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	size = SIZEOF(xOop);
	if (SIZEOF(yOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(pOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (isValVector) {
		if (SIZEOF(valOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	pArray = pOop.bytes;
	xArray = xOop.wordsAsFloat32Array();
	yArray = yOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	if (isValVector) {
		valArray = valOop.wordsAsFloat32Array();
	} else {
		val = interpreterProxy.floatValueOf(valOop);
	}
	for (i = 0; i <= (size - 1); i++) {
		if (pArray[i] === 1) {
			if (isValVector) {
				dist = valArray[i];
			} else {
				dist = val;
			}
			newX = xArray[i] + (dist * Math.cos(headingArray[i]));
			newY = yArray[i] - (dist * Math.sin(headingArray[i]));
			scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(i, xArray, headingArray, newX, destWidth, leftEdgeMode, rightEdgeMode);
			scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(i, yArray, headingArray, newY, destHeight, topEdgeMode, bottomEdgeMode);
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(11);
}

function primUpHill() {
	var bits;
	var bitsOop;
	var endX;
	var endY;
	var height;
	var maxVal;
	var maxValX;
	var maxValY;
	var ret;
	var rowOffset;
	var sniffRange;
	var startX;
	var startY;
	var tH;
	var tX;
	var tY;
	var thisVal;
	var turtleX;
	var turtleY;
	var width;
	var x;
	var y;

	/* inline: true */;
	sniffRange = interpreterProxy.stackIntegerValue(0);
	height = interpreterProxy.stackIntegerValue(1);
	width = interpreterProxy.stackIntegerValue(2);
	bitsOop = interpreterProxy.stackValue(3);
	tH = interpreterProxy.stackFloatValue(4);
	tY = interpreterProxy.stackFloatValue(5);
	tX = interpreterProxy.stackFloatValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(bitsOop) !== (height * width)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	bits = bitsOop.words;
	turtleX = tX;
	turtleY = tY;
	turtleX = Math.max(turtleX, 0);
	turtleY = Math.max(turtleY, 0);
	turtleX = Math.min(turtleX, (width - 1));
	turtleY = Math.min(turtleY, (height - 1));
	startX = Math.max((turtleX - sniffRange), 0);
	endX = Math.min((turtleX + sniffRange), (width - 1));
	startY = Math.max((turtleY - sniffRange), 0);
	endY = Math.min((turtleY + sniffRange), (height - 1));
	maxVal = bits[(turtleY * width) + turtleX];
	maxValX = -1;
	for (y = startY; y <= endY; y++) {
		rowOffset = y * width;
		for (x = startX; x <= endX; x++) {
			thisVal = bits[rowOffset + x];
			if (thisVal > maxVal) {
				maxValX = x;
				maxValY = y;
				maxVal = thisVal;
			}
		}
	}
	if (-1 === maxValX) {
		ret = radiansToDegrees(tH);
	} else {
		ret = degreesFromXy((maxValX - turtleX), (maxValY - turtleY)) + 90.0|0;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(8);
	interpreterProxy.pushFloat(ret);
}

function primitiveAddArrays() {
	var argOop;
	var floatsArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgWords && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] + wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] + floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] + wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] + floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveAddScalar() {
	var argOop;
	var floatArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgInt && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] + intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] + floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] + intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] + floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveAndByteArray() {
	var i;
	var length;
	var length1;
	var length2;
	var otherArray;
	var otherOop;
	var rcvrArray;
	var rcvrOop;

	/* inline: true */;
	otherOop = interpreterProxy.stackObjectValue(0);
	rcvrOop = interpreterProxy.stackValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isBytes(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(otherOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length1 = SIZEOF(rcvrOop);
	length2 = SIZEOF(otherOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	length = length1;
	if (length1 > length2) {
		length = length2;
	}
	otherArray = otherOop.bytes;
	rcvrArray = rcvrOop.bytes;
	for (i = 0; i <= (length - 1); i++) {
		rcvrArray[i] = ((rcvrArray[i] + otherArray[i]) === 2);
	}
	interpreterProxy.pop(1);
}

function primitiveDivArrays() {
	var argOop;
	var floatsArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgWords && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] / wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] / floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] / wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] / floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveDivScalar() {
	var argOop;
	var floatArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgInt && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (DIV(wordsRcvr[i], intArg));
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] / floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] / intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] / floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveEQArrays() {
	var argOop;
	var bytesResult;
	var floatsArg;
	var floatsRcvr;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] === wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] === floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] === wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] === floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveEQScalar() {
	var argOop;
	var bytesResult;
	var floatArg;
	var floatsRcvr;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] === intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] === floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] === intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] === floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveGEArrays() {
	var argOop;
	var bytesResult;
	var floatsArg;
	var floatsRcvr;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] >= wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] >= floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] >= wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] >= floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveGEScalar() {
	var argOop;
	var bytesResult;
	var floatArg;
	var floatsRcvr;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] >= intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] >= floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] >= intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] >= floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveGTArrays() {
	var argOop;
	var bytesResult;
	var floatsArg;
	var floatsRcvr;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] > wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] > floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] > wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] > floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveGTScalar() {
	var argOop;
	var bytesResult;
	var floatArg;
	var floatsRcvr;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] > intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] > floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] > intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] > floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveLEArrays() {
	var argOop;
	var bytesResult;
	var floatsArg;
	var floatsRcvr;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] <= wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] <= floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] <= wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] <= floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveLEScalar() {
	var argOop;
	var bytesResult;
	var floatArg;
	var floatsRcvr;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] <= intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] <= floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] <= intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] <= floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveLTArrays() {
	var argOop;
	var bytesResult;
	var floatsArg;
	var floatsRcvr;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] < wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] < floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] < wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] < floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveLTScalar() {
	var argOop;
	var bytesResult;
	var floatArg;
	var floatsRcvr;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] < intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] < floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] < intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] < floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveMulArrays() {
	var argOop;
	var floatsArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgWords && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] * wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] * floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] * wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] * floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveMulScalar() {
	var argOop;
	var floatArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgInt && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] * intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] * floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] * intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] * floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveNEArrays() {
	var argOop;
	var bytesResult;
	var floatsArg;
	var floatsRcvr;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] !== wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] !== floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] !== wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] !== floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveNEScalar() {
	var argOop;
	var bytesResult;
	var floatArg;
	var floatsRcvr;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] !== intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (wordsRcvr[i] !== floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] !== intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			bytesResult = resultOop.bytes;
			for (i = 0; i <= (length - 1); i++) {
				bytesResult[i] = (floatsRcvr[i] !== floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveNotByteArray() {
	var i;
	var length;
	var rcvrArray;
	var rcvrOop;

	/* inline: true */;
	rcvrOop = interpreterProxy.stackValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isBytes(rcvrOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	rcvrArray = rcvrOop.bytes;
	for (i = 0; i <= (length - 1); i++) {
		if (rcvrArray[i] === 0) {
			rcvrArray[i] = 1;
		} else {
			rcvrArray[i] = 0;
		}
	}
}

function primitiveOrByteArray() {
	var i;
	var length;
	var length1;
	var length2;
	var otherArray;
	var otherOop;
	var rcvrArray;
	var rcvrOop;

	/* inline: true */;
	otherOop = interpreterProxy.stackObjectValue(0);
	rcvrOop = interpreterProxy.stackValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isBytes(rcvrOop));
	interpreterProxy.success(interpreterProxy.isBytes(otherOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length1 = SIZEOF(rcvrOop);
	length2 = SIZEOF(otherOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	length = length1;
	if (length1 > length2) {
		length = length2;
	}
	otherArray = otherOop.bytes;
	rcvrArray = rcvrOop.bytes;
	for (i = 0; i <= (length - 1); i++) {
		rcvrArray[i] = ((rcvrArray[i] + otherArray[i]) > 0);
	}
	interpreterProxy.pop(1);
}

function primitivePredicateAtAllPutBoolean() {
	var i;
	var predicates;
	var predicatesOop;
	var rcvrOop;
	var val;
	var valOop;
	var values;
	var valuesOop;

	/* inline: true */;
	valOop = interpreterProxy.stackValue(0);
	rcvrOop = interpreterProxy.stackObjectValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (interpreterProxy.isIntegerValue(valOop)) {
		val = valOop;
	} else {
		val = interpreterProxy.booleanValueOf(valOop);
	}
	valuesOop = interpreterProxy.fetchPointerofObject(1, rcvrOop);
	predicatesOop = interpreterProxy.fetchPointerofObject(0, rcvrOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(predicatesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isBytes(valuesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	values = valuesOop.bytes;
	predicates = predicatesOop.bytes;
	for (i = 0; i <= (SIZEOF(valuesOop) - 1); i++) {
		if (predicates[i] === 1) {
			values[i] = val;
		}
	}
	interpreterProxy.pop(1);
}

function primitivePredicateAtAllPutColor() {
	var i;
	var predicates;
	var predicatesOop;
	var rcvrOop;
	var val;
	var values;
	var valuesOop;

	/* inline: true */;
	val = interpreterProxy.stackIntegerValue(0);
	rcvrOop = interpreterProxy.stackObjectValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	val = val | 4278190080;
	valuesOop = interpreterProxy.fetchPointerofObject(1, rcvrOop);
	predicatesOop = interpreterProxy.fetchPointerofObject(0, rcvrOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(predicatesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(valuesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	values = valuesOop.words;
	predicates = predicatesOop.bytes;
	for (i = 0; i <= (SIZEOF(valuesOop) - 1); i++) {
		if (predicates[i] === 1) {
			values[i] = val;
		}
	}
	interpreterProxy.pop(1);
}

function primitivePredicateAtAllPutNumber() {
	var i;
	var predicates;
	var predicatesOop;
	var rcvrOop;
	var val;
	var values;
	var valuesOop;

	/* inline: true */;
	val = interpreterProxy.stackFloatValue(0);
	rcvrOop = interpreterProxy.stackObjectValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	valuesOop = interpreterProxy.fetchPointerofObject(1, rcvrOop);
	predicatesOop = interpreterProxy.fetchPointerofObject(0, rcvrOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(predicatesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(valuesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	values = valuesOop.wordsAsFloat32Array();
	predicates = predicatesOop.bytes;
	for (i = 0; i <= (SIZEOF(valuesOop) - 1); i++) {
		if (predicates[i] === 1) {
			values[i] = val;
		}
	}
	interpreterProxy.pop(1);
}

function primitivePredicateAtAllPutObject() {
	var i;
	var predicates;
	var predicatesOop;
	var rcvrOop;
	var valOop;
	var values;
	var valuesOop;

	/* inline: true */;
	valOop = interpreterProxy.stackValue(0);
	rcvrOop = interpreterProxy.stackObjectValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	valuesOop = interpreterProxy.fetchPointerofObject(1, rcvrOop);
	predicatesOop = interpreterProxy.fetchPointerofObject(0, rcvrOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(predicatesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isPointers(valuesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	values = valuesOop.wordsAsInt32Array();
	predicates = predicatesOop.bytes;
	for (i = 0; i <= (SIZEOF(valuesOop) - 1); i++) {
		if (predicates[i] === 1) {
			values[i] = valOop;
		}
	}
	interpreterProxy.pop(1);
}

function primitivePredicateReplaceBytes() {
	var i;
	var predicates;
	var predicatesOop;
	var predicatesSize;
	var rcvrOop;
	var repOop;
	var repStart;
	var replacement;
	var replacementSize;
	var start;
	var stop;
	var values;
	var valuesOop;
	var valuesSize;

	/* inline: true */;
	repStart = interpreterProxy.stackIntegerValue(0);
	repOop = interpreterProxy.stackObjectValue(1);
	stop = interpreterProxy.stackIntegerValue(2);
	start = interpreterProxy.stackIntegerValue(3);
	rcvrOop = interpreterProxy.stackObjectValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	valuesOop = interpreterProxy.fetchPointerofObject(1, rcvrOop);
	predicatesOop = interpreterProxy.fetchPointerofObject(0, rcvrOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(predicatesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!(interpreterProxy.isBytes(valuesOop) && (interpreterProxy.isBytes(repOop)))) {
		interpreterProxy.primitiveFail();
		return null;
	}
	values = valuesOop.bytes;
	predicates = predicatesOop.bytes;
	replacement = repOop.bytes;
	valuesSize = SIZEOF(valuesOop);
	predicatesSize = SIZEOF(predicatesOop);
	replacementSize = SIZEOF(repOop);
	if (start > stop) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (start < 1) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (start > valuesSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (start > predicatesSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (stop > valuesSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (stop > predicatesSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (repStart < 1) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (repStart > replacementSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (((replacementSize - repStart) + 1) < ((stop - start) + 1)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	for (i = (start - 1); i <= (stop - 1); i++) {
		if (predicates[i] === 1) {
			values[i] = replacement[(repStart + i) - start];
		}
	}
	interpreterProxy.pop(4);
}

function primitivePredicateReplaceWords() {
	var floatReplacement;
	var floatValues;
	var fv;
	var i;
	var predicates;
	var predicatesOop;
	var predicatesSize;
	var rIsFloat;
	var rcvrOop;
	var repOop;
	var repStart;
	var replacement;
	var replacementSize;
	var start;
	var stop;
	var vIsFloat;
	var values;
	var valuesOop;
	var valuesSize;

	/* inline: true */;
	repStart = interpreterProxy.stackIntegerValue(0);
	repOop = interpreterProxy.stackObjectValue(1);
	stop = interpreterProxy.stackIntegerValue(2);
	start = interpreterProxy.stackIntegerValue(3);
	rcvrOop = interpreterProxy.stackObjectValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	valuesOop = interpreterProxy.fetchPointerofObject(1, rcvrOop);
	predicatesOop = interpreterProxy.fetchPointerofObject(0, rcvrOop);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(predicatesOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!((interpreterProxy.isWords(valuesOop) && (interpreterProxy.isWords(repOop))) || (interpreterProxy.isPointers(valuesOop) && (interpreterProxy.isPointers(repOop))))) {
		interpreterProxy.primitiveFail();
		return null;
	}
	predicates = predicatesOop.bytes;
	valuesSize = SIZEOF(valuesOop);
	predicatesSize = SIZEOF(predicatesOop);
	replacementSize = SIZEOF(repOop);
	if (start > stop) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (start < 1) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (start > valuesSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (start > predicatesSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (stop > valuesSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (stop > predicatesSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (repStart < 1) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (repStart > replacementSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (((replacementSize - repStart) + 1) < ((stop - start) + 1)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	vIsFloat = interpreterProxy.isMemberOf(valuesOop, "KedamaFloatArray");
	rIsFloat = interpreterProxy.isMemberOf(repOop, "KedamaFloatArray");
	if (vIsFloat && (rIsFloat)) {
		floatValues = valuesOop.wordsAsFloat32Array();
		floatReplacement = repOop.wordsAsFloat32Array();
		for (i = (start - 1); i <= (stop - 1); i++) {
			if (predicates[i] === 1) {
				floatValues[i] = floatReplacement[(repStart + i) - start];
			}
		}
	}
	if (vIsFloat && (!rIsFloat)) {
		floatValues = valuesOop.wordsAsFloat32Array();
		replacement = repOop.words;
		for (i = (start - 1); i <= (stop - 1); i++) {
			if (predicates[i] === 1) {
				floatValues[i] = replacement[(repStart + i) - start];
			}
		}
	}
	if (!vIsFloat && (rIsFloat)) {
		values = valuesOop.words;
		floatReplacement = repOop.wordsAsFloat32Array();
		for (i = (start - 1); i <= (stop - 1); i++) {
			if (predicates[i] === 1) {
				fv = (floatReplacement[(repStart + i) - start]>>>0);
				;
				values[i] = fv;
			}
		}
	}
	if (!vIsFloat && (!rIsFloat)) {
		values = valuesOop.words;
		replacement = repOop.words;
		for (i = (start - 1); i <= (stop - 1); i++) {
			if (predicates[i] === 1) {
				values[i] = replacement[(repStart + i) - start];
			}
		}
	}
	interpreterProxy.pop(4);
}

function primitiveRemArrays() {
	var argOop;
	var floatArg;
	var floatRcvr;
	var floatResult;
	var floatsArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordArg;
	var wordRcvr;
	var wordResult;
	var wordsArg;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgWords && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordRcvr = wordsRcvr[i];
				wordArg = wordsArg[i];

				/* In this primitive, words are supposed to be unsigned. */

				wordResult = MOD(wordRcvr, wordArg);
				wordsResult[i] = wordResult;
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				wordRcvr = wordsRcvr[i];
				floatArg = floatsArg[i];
				floatResult = wordRcvr / floatArg;
				floatResult = Math.floor(floatResult);
				floatsResult[i] = (wordRcvr - (floatResult * floatArg));
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatRcvr = floatsRcvr[i];
				wordArg = wordsArg[i];
				floatResult = floatRcvr / wordArg;
				floatResult = Math.floor(floatResult);
				floatsResult[i] = (floatRcvr - (floatResult * wordArg));
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatRcvr = floatsRcvr[i];
				floatArg = floatsArg[i];
				floatResult = floatRcvr / floatArg;
				floatResult = Math.floor(floatResult);
				floatsResult[i] = (floatRcvr - (floatResult * floatArg));
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveRemScalar() {
	var argOop;
	var floatArg;
	var floatRcvr;
	var floatResult;
	var floatsRcvr;
	var floatsResult;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordRcvr;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgInt && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (MOD(wordsRcvr[i], intArg));
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				wordRcvr = wordsRcvr[i];
				floatResult = wordRcvr / floatArg;
				floatResult = Math.floor(floatResult);
				floatsResult[i] = (wordRcvr - (floatResult * floatArg));
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatRcvr = floatsRcvr[i];
				floatResult = floatRcvr / intArg;
				floatResult = Math.floor(floatResult);
				floatsResult[i] = (floatRcvr - (floatResult * intArg));
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatRcvr = floatsRcvr[i];
				floatResult = floatRcvr / floatArg;
				floatResult = Math.floor(floatResult);
				floatsResult[i] = (floatRcvr - (floatResult * floatArg));
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveSubArrays() {
	var argOop;
	var floatsArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgWords && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] - wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] - floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] - wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] - floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveSubScalar() {
	var argOop;
	var floatArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgInt && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] - intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] - floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] - intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] - floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function radiansToDegrees(radians) {
	var deg;
	var degrees;

	/* inline: true */;
	degrees = radians / 0.0174532925199433;
	deg = 90.0 - degrees;
	if (!(deg > 0.0)) {
		deg += 360.0;
	}
	return deg;
}

function randomIntoFloatArray() {
	var factor;
	var floatArray;
	var floatArrayOop;
	var from;
	var index;
	var range;
	var size;
	var to;

	/* inline: true */;
	factor = interpreterProxy.stackFloatValue(0);
	floatArrayOop = interpreterProxy.stackValue(1);
	to = interpreterProxy.stackIntegerValue(2);
	from = interpreterProxy.stackIntegerValue(3);
	range = interpreterProxy.stackIntegerValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(floatArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(floatArrayOop);
	if (!((size >= to) && ((from >= 1) && (to >= from)))) {
		interpreterProxy.primitiveFail();
		return null;
	}
	floatArray = floatArrayOop.wordsAsFloat32Array();
	if (interpreterProxy.failed()) {
		return null;
	}
	for (index = from; index <= to; index++) {
		floatArray[index - 1] = (kedamaRandom2(range) * factor);
	}
	interpreterProxy.pop(5);
}

function randomIntoIntegerArray() {
	var factor;
	var from;
	var index;
	var integerArray;
	var integerArrayOop;
	var range;
	var size;
	var to;

	/* inline: true */;
	factor = interpreterProxy.stackFloatValue(0);
	integerArrayOop = interpreterProxy.stackValue(1);
	to = interpreterProxy.stackIntegerValue(2);
	from = interpreterProxy.stackIntegerValue(3);
	range = interpreterProxy.stackIntegerValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(integerArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(integerArrayOop);
	if (!((size >= to) && ((from >= 1) && (to >= from)))) {
		interpreterProxy.primitiveFail();
		return null;
	}
	integerArray = integerArrayOop.words;
	if (interpreterProxy.failed()) {
		return null;
	}
	for (index = from; index <= to; index++) {
		integerArray[index - 1] = ((kedamaRandom2(range) * factor)|0);
	}
	interpreterProxy.pop(5);
}

function randomRange() {
	var range;
	var ret;

	/* inline: true */;
	range = interpreterProxy.stackIntegerValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	ret = kedamaRandom2(range);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(2);
	interpreterProxy.pushInteger(ret);
}

function scalarGetAngleTo() {
	var fromX;
	var fromY;
	var r;
	var toX;
	var toY;
	var x;
	var y;

	/* inline: true */;
	fromY = interpreterProxy.stackFloatValue(0);
	fromX = interpreterProxy.stackFloatValue(1);
	toY = interpreterProxy.stackFloatValue(2);
	toX = interpreterProxy.stackFloatValue(3);
	if (interpreterProxy.failed()) {
		return null;
	}
	x = toX - fromX;
	y = toY - fromY;
	r = degreesFromXy(x, y);
	r += 90.0;
	if (r > 360.0) {
		r -= 360.0;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(5);
	interpreterProxy.pushFloat(r);
}

function scalarGetDistanceTo() {
	var fromX;
	var fromY;
	var r;
	var toX;
	var toY;
	var x;
	var y;

	/* inline: true */;
	fromY = interpreterProxy.stackFloatValue(0);
	fromX = interpreterProxy.stackFloatValue(1);
	toY = interpreterProxy.stackFloatValue(2);
	toX = interpreterProxy.stackFloatValue(3);
	if (interpreterProxy.failed()) {
		return null;
	}
	x = fromX - toX;
	y = fromY - toY;
	r = Math.sqrt((x * x) + (y * y));
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(5);
	interpreterProxy.pushFloat(r);
}

function scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(index, xArray, headingArray, val, destWidth, leftEdgeMode, rightEdgeMode) {
	var headingRadians;
	var newX;

	/* inline: true */;
	newX = val;
	if (newX < 0.0) {
		if (leftEdgeMode === 1) {

			/* wrap */

			newX += destWidth;
		}
		if (leftEdgeMode === 2) {

			/* stick */

			newX = 0.0;
		}
		if (leftEdgeMode === 3) {

			/* bounce */

			newX = 0.0 - newX;
			headingRadians = headingArray[index];
			if (headingRadians < 3.141592653589793) {
				headingArray[index] = (3.141592653589793 - headingRadians);
			} else {
				headingArray[index] = (9.42477796076938 - headingRadians);
			}
		}
	}
	if (newX >= destWidth) {
		if (rightEdgeMode === 1) {
			newX -= destWidth;
		}
		if (rightEdgeMode === 2) {
			newX = destWidth - 1.0e-6;
		}
		if (rightEdgeMode === 3) {
			newX = (destWidth - 1.0e-6) - (newX - destWidth);
			headingRadians = headingArray[index];
			if (headingRadians < 3.141592653589793) {
				headingArray[index] = (3.141592653589793 - headingRadians);
			} else {
				headingArray[index] = (9.42477796076938 - headingRadians);
			}
		}
	}
	xArray[index] = newX;
}

function scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(index, yArray, headingArray, val, destHeight, topEdgeMode, bottomEdgeMode) {
	var newY;

	/* inline: true */;
	newY = val;
	if (newY < 0.0) {
		if (topEdgeMode === 1) {

			/* wrap */

			newY += destHeight;
		}
		if (topEdgeMode === 2) {

			/* stick */

			newY = 0.0;
		}
		if (topEdgeMode === 3) {

			/* bounce */

			newY = 0.0 - newY;
			headingArray[index] = (6.283185307179586 - headingArray[index]);
		}
	}
	if (newY >= destHeight) {
		if (bottomEdgeMode === 1) {
			newY -= destHeight;
		}
		if (bottomEdgeMode === 2) {
			newY = destHeight - 1.0e-6;
		}
		if (bottomEdgeMode === 3) {
			newY = (destHeight - 1.0e-6) - (newY - destHeight);
			headingArray[index] = (6.283185307179586 - headingArray[index]);
		}
	}
	yArray[index] = newY;
}

function setHeadingArrayFrom() {
	var heading;
	var headingArray;
	var headingOop;
	var i;
	var isValVector;
	var pArray;
	var pOop;
	var resultArray;
	var resultOop;
	var size;

	/* inline: true */;
	resultOop = interpreterProxy.stackValue(0);
	headingOop = interpreterProxy.stackValue(1);
	pOop = interpreterProxy.stackValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(pOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(headingOop);
	if (resultOop.isFloat) {
		isValVector = false;
	} else {
		if (interpreterProxy.isWords(resultOop)) {
			if (SIZEOF(resultOop) !== size) {
				interpreterProxy.primitiveFail();
				return null;
			}
			isValVector = true;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	pArray = pOop.bytes;
	headingArray = headingOop.wordsAsFloat32Array();
	if (isValVector) {
		resultArray = resultOop.wordsAsFloat32Array();
	} else {
		heading = interpreterProxy.floatValueOf(resultOop);
		heading = degreesToRadians(heading);
	}
	for (i = 0; i <= (size - 1); i++) {
		if (pArray[i] === 1) {
			if (isValVector) {
				heading = resultArray[i];
				heading = degreesToRadians(heading);
			}
			headingArray[i] = heading;
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(3);
}


/*	Note: This is coded so that is can be run from Squeak. */

function setInterpreter(anInterpreter) {
	var ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy.majorVersion() == VM_PROXY_MAJOR;
	if (ok === false) {
		return false;
	}
	ok = interpreterProxy.minorVersion() >= VM_PROXY_MINOR;
	return ok;
}

function setScalarHeading() {
	var heading;
	var headingArray;
	var headingOop;
	var index;

	/* inline: true */;
	heading = interpreterProxy.stackFloatValue(0);
	headingOop = interpreterProxy.stackValue(1);
	index = interpreterProxy.stackIntegerValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) < index) {
		interpreterProxy.primitiveFail();
		return null;
	}
	headingArray = headingOop.wordsAsFloat32Array();
	headingArray[index - 1] = degreesToRadians(heading);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(3);
}

function shutdownModule() {
	return true;
}

function turtleScalarSetX() {
	var destWidth;
	var headingArray;
	var headingOop;
	var leftEdgeMode;
	var rightEdgeMode;
	var size;
	var val;
	var xArray;
	var xIndex;
	var xOop;

	/* inline: true */;
	rightEdgeMode = interpreterProxy.stackIntegerValue(0);
	leftEdgeMode = interpreterProxy.stackIntegerValue(1);
	destWidth = interpreterProxy.stackFloatValue(2);
	val = interpreterProxy.stackFloatValue(3);
	headingOop = interpreterProxy.stackValue(4);
	xIndex = interpreterProxy.stackIntegerValue(5);
	xOop = interpreterProxy.stackValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xOop);
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(xIndex - 1, xArray, headingArray, val, destWidth, leftEdgeMode, rightEdgeMode);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(7);
}

function turtleScalarSetY() {
	var bottomEdgeMode;
	var destHeight;
	var headingArray;
	var headingOop;
	var size;
	var topEdgeMode;
	var val;
	var yArray;
	var yIndex;
	var yOop;

	/* inline: true */;
	bottomEdgeMode = interpreterProxy.stackIntegerValue(0);
	topEdgeMode = interpreterProxy.stackIntegerValue(1);
	destHeight = interpreterProxy.stackFloatValue(2);
	val = interpreterProxy.stackFloatValue(3);
	headingOop = interpreterProxy.stackValue(4);
	yIndex = interpreterProxy.stackIntegerValue(5);
	yOop = interpreterProxy.stackValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(yOop);
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	yArray = yOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(yIndex - 1, yArray, headingArray, val, destHeight, topEdgeMode, bottomEdgeMode);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(7);
}

function turtlesSetX() {
	var destWidth;
	var headingArray;
	var headingOop;
	var i;
	var isValVector;
	var isWordVector;
	var leftEdgeMode;
	var newX;
	var pArray;
	var pOop;
	var rightEdgeMode;
	var size;
	var val;
	var valArray;
	var valOop;
	var wordValArray;
	var xArray;
	var xOop;

	/* inline: true */;
	rightEdgeMode = interpreterProxy.stackIntegerValue(0);
	leftEdgeMode = interpreterProxy.stackIntegerValue(1);
	destWidth = interpreterProxy.stackFloatValue(2);
	valOop = interpreterProxy.stackValue(3);
	headingOop = interpreterProxy.stackValue(4);
	xOop = interpreterProxy.stackValue(5);
	pOop = interpreterProxy.stackValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(pOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (valOop.isFloat) {
		isValVector = false;
	} else {
		if (interpreterProxy.isWords(valOop)) {
			isValVector = true;
			isWordVector = interpreterProxy.isMemberOf(valOop, "WordArray");
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	size = SIZEOF(xOop);
	if (SIZEOF(pOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (isValVector) {
		if (SIZEOF(valOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	pArray = pOop.bytes;
	xArray = xOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	if (isValVector) {
		if (isWordVector) {
			wordValArray = valOop.words;
		} else {
			valArray = valOop.wordsAsFloat32Array();
		}
	} else {
		val = interpreterProxy.floatValueOf(valOop);
	}
	for (i = 0; i <= (size - 1); i++) {
		if (pArray[i] === 1) {
			if (isValVector) {
				if (isWordVector) {
					newX = wordValArray[i];
					;
				} else {
					newX = valArray[i];
				}
			} else {
				newX = val;
			}
			scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(i, xArray, headingArray, newX, destWidth, leftEdgeMode, rightEdgeMode);
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(7);
}

function turtlesSetY() {
	var bottomEdgeMode;
	var destHeight;
	var headingArray;
	var headingOop;
	var i;
	var isValVector;
	var isWordVector;
	var newY;
	var pArray;
	var pOop;
	var size;
	var topEdgeMode;
	var val;
	var valArray;
	var valOop;
	var wordValArray;
	var yArray;
	var yOop;

	/* inline: true */;
	bottomEdgeMode = interpreterProxy.stackIntegerValue(0);
	topEdgeMode = interpreterProxy.stackIntegerValue(1);
	destHeight = interpreterProxy.stackFloatValue(2);
	valOop = interpreterProxy.stackValue(3);
	headingOop = interpreterProxy.stackValue(4);
	yOop = interpreterProxy.stackValue(5);
	pOop = interpreterProxy.stackValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isBytes(pOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (valOop.isFloat) {
		isValVector = false;
	} else {
		if (interpreterProxy.isWords(valOop)) {
			isValVector = true;
			isWordVector = interpreterProxy.isMemberOf(valOop, "WordArray");
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	size = SIZEOF(yOop);
	if (SIZEOF(pOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (isValVector) {
		if (SIZEOF(valOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	pArray = pOop.bytes;
	yArray = yOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	if (isValVector) {
		if (isWordVector) {
			wordValArray = valOop.words;
		} else {
			valArray = valOop.wordsAsFloat32Array();
		}
	} else {
		val = interpreterProxy.floatValueOf(valOop);
	}
	for (i = 0; i <= (size - 1); i++) {
		if (pArray[i] === 1) {
			if (isValVector) {
				if (isWordVector) {
					newY = wordValArray[i];
					;
				} else {
					newY = valArray[i];
				}
			} else {
				newY = val;
			}
			scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(i, yArray, headingArray, newY, destHeight, topEdgeMode, bottomEdgeMode);
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(7);
}

function vectorGetAngleTo() {
	var index;
	var isVector;
	var pX;
	var pXOop;
	var pY;
	var pYOop;
	var ppx;
	var ppy;
	var r;
	var result;
	var resultOop;
	var size;
	var x;
	var xArray;
	var xArrayOop;
	var y;
	var yArray;
	var yArrayOop;

	/* inline: true */;
	resultOop = interpreterProxy.stackValue(0);
	yArrayOop = interpreterProxy.stackValue(1);
	xArrayOop = interpreterProxy.stackValue(2);
	pYOop = interpreterProxy.stackValue(3);
	pXOop = interpreterProxy.stackValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(resultOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(resultOop);
	if (size < 0) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(xArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(yArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (pXOop.isFloat) {
		if (pYOop.isFloat) {
			isVector = false;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (pYOop.isFloat) {
			interpreterProxy.primitiveFail();
			return null;
		} else {
			isVector = true;
		}
	}
	if (isVector) {
		if (SIZEOF(pXOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
		if (SIZEOF(pYOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	result = resultOop.wordsAsFloat32Array();
	xArray = xArrayOop.wordsAsFloat32Array();
	yArray = yArrayOop.wordsAsFloat32Array();
	if (isVector) {
		pX = pXOop.wordsAsFloat32Array();
		pY = pYOop.wordsAsFloat32Array();
	}
	if (!isVector) {
		ppx = interpreterProxy.floatValueOf(pXOop);
		ppy = interpreterProxy.floatValueOf(pYOop);
	}
	for (index = 0; index <= (size - 1); index++) {
		if (isVector) {
			ppx = pX[index];
			ppy = pY[index];
		}
		x = ppx - xArray[index];
		y = ppy - yArray[index];
		r = degreesFromXy(x, y);
		r += 90.0;
		if (r > 360.0) {
			r -= 360.0;
		}
		result[index] = r;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
	interpreterProxy.push(resultOop);
}

function vectorGetDistanceTo() {
	var index;
	var isVector;
	var pX;
	var pXOop;
	var pY;
	var pYOop;
	var ppx;
	var ppy;
	var result;
	var resultOop;
	var size;
	var x;
	var xArray;
	var xArrayOop;
	var y;
	var yArray;
	var yArrayOop;

	/* inline: true */;
	resultOop = interpreterProxy.stackValue(0);
	yArrayOop = interpreterProxy.stackValue(1);
	xArrayOop = interpreterProxy.stackValue(2);
	pYOop = interpreterProxy.stackValue(3);
	pXOop = interpreterProxy.stackValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(resultOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(resultOop);
	if (size < 0) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(xArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(yArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (pXOop.isFloat) {
		if (pYOop.isFloat) {
			isVector = false;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (pYOop.isFloat) {
			interpreterProxy.primitiveFail();
			return null;
		} else {
			isVector = true;
		}
	}
	if (isVector) {
		if (SIZEOF(pXOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
		if (SIZEOF(pYOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	result = resultOop.wordsAsFloat32Array();
	xArray = xArrayOop.wordsAsFloat32Array();
	yArray = yArrayOop.wordsAsFloat32Array();
	if (isVector) {
		pX = pXOop.wordsAsFloat32Array();
		pY = pYOop.wordsAsFloat32Array();
	}
	if (!isVector) {
		ppx = interpreterProxy.floatValueOf(pXOop);
		ppy = interpreterProxy.floatValueOf(pYOop);
	}
	for (index = 0; index <= (size - 1); index++) {
		if (isVector) {
			ppx = pX[index];
			ppy = pY[index];
		}
		x = ppx - xArray[index];
		y = ppy - yArray[index];
		result[index] = Math.sqrt((x * x) + (y * y));
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
	interpreterProxy.push(resultOop);
}

function zoomBitmap() {
	var bit;
	var dOrigin;
	var dst;
	var dstIndex;
	var dstSize;
	var dummy;
	var sHeight;
	var sOrigin;
	var sWidth;
	var src;
	var srcIndex;
	var srcOrigin;
	var srcSize;
	var sx;
	var sy;
	var xFactor;
	var y;
	var yFactor;

	/* inline: true */;
	yFactor = interpreterProxy.stackIntegerValue(0);
	xFactor = interpreterProxy.stackIntegerValue(1);
	sHeight = interpreterProxy.stackIntegerValue(2);
	sWidth = interpreterProxy.stackIntegerValue(3);
	dst = interpreterProxy.stackValue(4);
	src = interpreterProxy.stackValue(5);
	if (interpreterProxy.failed()) {
		return null;
	}
	srcSize = SIZEOF(src);
	dstSize = SIZEOF(dst);
	if ((sWidth * sHeight) !== srcSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (((srcSize * xFactor) * yFactor) !== dstSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	sOrigin = src.words;
	dOrigin = dst.words;
	srcIndex = 0;
	srcOrigin = 0;
	dstIndex = 0;
	for (sy = 0; sy <= (sHeight - 1); sy++) {
		for (y = 0; y <= (yFactor - 1); y++) {
			for (sx = 0; sx <= (sWidth - 1); sx++) {
				bit = sOrigin[srcIndex];
				++srcIndex;
				for (dummy = 0; dummy <= (xFactor - 1); dummy++) {
					dOrigin[dstIndex] = bit;
					++dstIndex;
				}
			}
			srcIndex = srcOrigin;
		}
		srcOrigin += sWidth;
		srcIndex = srcOrigin;
	}
	interpreterProxy.pop(6);
}


function registerPlugin() {
	if (typeof Squeak === "object" && Squeak.registerExternalModule) {
		Squeak.registerExternalModule("KedamaPlugin2", {
			primitiveAddArrays: primitiveAddArrays,
			getModuleName: getModuleName,
			primitiveMulArrays: primitiveMulArrays,
			drawTurtlesInArray: drawTurtlesInArray,
			primitiveGTScalar: primitiveGTScalar,
			setScalarHeading: setScalarHeading,
			primitiveSubScalar: primitiveSubScalar,
			turtleScalarSetY: turtleScalarSetY,
			vectorGetAngleTo: vectorGetAngleTo,
			primitiveRemArrays: primitiveRemArrays,
			primitiveLTArrays: primitiveLTArrays,
			primitiveAddScalar: primitiveAddScalar,
			primPixelsAtXY: primPixelsAtXY,
			primitiveMulScalar: primitiveMulScalar,
			primSetPixelsAtXY: primSetPixelsAtXY,
			setHeadingArrayFrom: setHeadingArrayFrom,
			primPixelAtXYPut: primPixelAtXYPut,
			makeMaskLog: makeMaskLog,
			primitiveLTScalar: primitiveLTScalar,
			scalarGetAngleTo: scalarGetAngleTo,
			primitiveOrByteArray: primitiveOrByteArray,
			primitiveLEArrays: primitiveLEArrays,
			primitiveRemScalar: primitiveRemScalar,
			getHeadingArrayInto: getHeadingArrayInto,
			turtlesSetX: turtlesSetX,
			primitivePredicateReplaceBytes: primitivePredicateReplaceBytes,
			primitiveDivArrays: primitiveDivArrays,
			makeMask: makeMask,
			primitiveLEScalar: primitiveLEScalar,
			kedamaSetRandomSeed: kedamaSetRandomSeed,
			randomIntoIntegerArray: randomIntoIntegerArray,
			setInterpreter: setInterpreter,
			primitivePredicateAtAllPutColor: primitivePredicateAtAllPutColor,
			makeTurtlesMap: makeTurtlesMap,
			randomIntoFloatArray: randomIntoFloatArray,
			primUpHill: primUpHill,
			shutdownModule: shutdownModule,
			primitiveDivScalar: primitiveDivScalar,
			primitiveGEArrays: primitiveGEArrays,
			primitiveNotByteArray: primitiveNotByteArray,
			randomRange: randomRange,
			initialiseModule: initialiseModule,
			getScalarHeading: getScalarHeading,
			primPixelAtXY: primPixelAtXY,
			primitivePredicateAtAllPutNumber: primitivePredicateAtAllPutNumber,
			primitiveEQArrays: primitiveEQArrays,
			primitiveNEArrays: primitiveNEArrays,
			primScalarForward: primScalarForward,
			vectorGetDistanceTo: vectorGetDistanceTo,
			turtlesSetY: turtlesSetY,
			turtleScalarSetX: turtleScalarSetX,
			primTurtlesForward: primTurtlesForward,
			primitiveGEScalar: primitiveGEScalar,
			primitiveAndByteArray: primitiveAndByteArray,
			primitivePredicateReplaceWords: primitivePredicateReplaceWords,
			primitiveGTArrays: primitiveGTArrays,
			primitivePredicateAtAllPutObject: primitivePredicateAtAllPutObject,
			primitiveEQScalar: primitiveEQScalar,
			primitivePredicateAtAllPutBoolean: primitivePredicateAtAllPutBoolean,
			zoomBitmap: zoomBitmap,
			primitiveNEScalar: primitiveNEScalar,
			scalarGetDistanceTo: scalarGetDistanceTo,
			primitiveSubArrays: primitiveSubArrays,
		});
	} else self.setTimeout(registerPlugin, 100);
}

registerPlugin();

})(); // Register module/plugin
