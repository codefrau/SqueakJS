/* Smalltalk from Squeak4.5 with VMMaker 4.13.6 translated as JS source on 7 October 2014 4:13:21 pm */
/* Automatically generated by
	JSPluginCodeGenerator VMMakerJS-bf.9 uuid: 106da862-799b-4ae6-b42f-b80f05dcc86b
   from
	DSAPlugin VMMaker-bf.351 uuid: af5fd014-b9f4-4d17-80fa-2abd7b2b263b
 */

module("users.bert.SqueakJS.plugins.DSAPrims").requires("users.bert.SqueakJS.vm").toRun(function() {

var VM_PROXY_MAJOR = 1;
var VM_PROXY_MINOR = 11;

/*** Functions ***/
function CLASSOF(obj) { return typeof obj === "number" ? interpreterProxy.classSmallInteger() : obj.sqClass }
function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : 0 }
function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : 0 }
function DIV(a, b) { return Math.floor(a / b) | 0; }   // integer division
function MOD(a, b) { return a - DIV(a, b) * b | 0; }   // signed modulus
function SHL(a, b) { return b > 31 ? 0 : a << b; }     // fix JS shift
function SHR(a, b) { return b > 31 ? 0 : a >>> b; }    // fix JS shift
function SHIFT(a, b) { return b < 0 ? (b < -31 ? 0 : a >>> (0-b) ) : (b > 31 ? 0 : a << b); }

/*** Variables ***/
var divisorDigitCount = 0;
var dsaDivisor = null;
var dsaQuotient = null;
var dsaRemainder = null;
var interpreterProxy = null;
var moduleName = "DSAPrims 7 October 2014 (e)";
var remainderDigitCount = 0;



/*	Add back the divisor shifted left by the given number of digits. This is done only when the estimate of quotient digit was one larger than the correct value. */

function addBackDivisorDigitShift(digitShift) {
	var carry;
	var i;
	var rIndex;
	var sum;

	carry = 0;
	rIndex = digitShift + 1;
	for (i = 1; i <= divisorDigitCount; i++) {
		sum = ((dsaRemainder[rIndex]) + (dsaDivisor[i])) + carry;
		dsaRemainder[rIndex] = (sum & 255);
		carry = sum >>> 8;
		++rIndex;
	}
	sum = (dsaRemainder[rIndex]) + carry;
	dsaRemainder[rIndex] = (sum & 255);
}


/*	This is the core of the divide algorithm. This loop steps through the digit positions of the quotient, each time estimating the right quotient digit, subtracting from the remainder the divisor times the quotient digit shifted left by the appropriate number of digits. When the loop terminates, all digits of the quotient have been filled in and the remainder contains a value less than the divisor. The tricky bit is estimating the next quotient digit. Knuth shows that the digit estimate computed here will never be less than it should be and cannot be more than one over what it should be. Furthermore, the case where the estimate is one too large is extremely rare. For example, in a typical test of 100000 random 60-bit division problems, the rare case only occured five times. See Knuth, volume 2 ('Semi-Numerical Algorithms') 2nd edition, pp. 257-260 */
/*	extract the top two digits of the divisor */

function bigDivideLoop() {
	var d1;
	var d2;
	var digitShift;
	var firstDigit;
	var firstTwoDigits;
	var j;
	var q;
	var qTooBig;
	var thirdDigit;

	d1 = dsaDivisor[divisorDigitCount];
	d2 = dsaDivisor[divisorDigitCount - 1];
	for (j = remainderDigitCount; j >= (divisorDigitCount + 1); j += -1) {

		/* extract the top several digits of remainder. */

		firstDigit = dsaRemainder[j];
		firstTwoDigits = (firstDigit << 8) + (dsaRemainder[j - 1]);

		/* estimate q, the next digit of the quotient */

		thirdDigit = dsaRemainder[j - 2];
		if (firstDigit === d1) {
			q = 255;
		} else {
			q = DIV(firstTwoDigits, d1);
		}
		if ((d2 * q) > (((firstTwoDigits - (q * d1)) << 8) + thirdDigit)) {
			--q;
			if ((d2 * q) > (((firstTwoDigits - (q * d1)) << 8) + thirdDigit)) {
				--q;
			}
		}
		digitShift = (j - divisorDigitCount) - 1;
		if (q > 0) {
			qTooBig = subtractDivisorMultipliedByDigitdigitShift(q, digitShift);
			if (qTooBig) {

				/* this case is extremely rare */

				addBackDivisorDigitShift(digitShift);
				--q;
			}
		}
		dsaQuotient[digitShift + 1] = q;
	}
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

function getModuleName() {
	return moduleName;
}

function halt() {
	;
}


/*	Rotate the given 32-bit integer left by the given number of bits and answer the result. */

function leftRotateby(anInteger, bits) {
	return (SHL(anInteger, bits)) | (SHR(anInteger, (32 - bits)));
}


/*	Called with three LargePositiveInteger arguments, rem, div, quo. Divide div into rem and store the quotient into quo, leaving the remainder in rem. */
/*	Assume: quo starts out filled with zeros. */

function primitiveBigDivide() {
	var div;
	var quo;
	var rem;

	quo = interpreterProxy.stackObjectValue(0);
	div = interpreterProxy.stackObjectValue(1);
	rem = interpreterProxy.stackObjectValue(2);
	interpreterProxy.success((CLASSOF(rem)) === (interpreterProxy.classLargePositiveInteger()));
	interpreterProxy.success((CLASSOF(div)) === (interpreterProxy.classLargePositiveInteger()));
	interpreterProxy.success((CLASSOF(quo)) === (interpreterProxy.classLargePositiveInteger()));
	if (interpreterProxy.failed()) {
		return null;
	}
	dsaRemainder = rem.bytes;
	dsaDivisor = div.bytes;
	dsaQuotient = quo.bytes;
	divisorDigitCount = SIZEOF(div);

	/* adjust pointers for base-1 indexing */

	remainderDigitCount = SIZEOF(rem);
	--dsaRemainder;
	--dsaDivisor;
	--dsaQuotient;
	bigDivideLoop();
	interpreterProxy.pop(3);
}


/*	Multiple f1 by f2, placing the result into prod. f1, f2, and prod must be LargePositiveIntegers, and the length of prod must be the sum of the lengths of f1 and f2. */
/*	Assume: prod starts out filled with zeros */

function primitiveBigMultiply() {
	var carry;
	var digit;
	var f1;
	var f1Len;
	var f1Ptr;
	var f2;
	var f2Len;
	var f2Ptr;
	var i;
	var j;
	var k;
	var prod;
	var prodLen;
	var prodPtr;
	var sum;

	prod = interpreterProxy.stackObjectValue(0);
	f2 = interpreterProxy.stackObjectValue(1);
	f1 = interpreterProxy.stackObjectValue(2);
	interpreterProxy.success(interpreterProxy.isBytes(prod));
	interpreterProxy.success(interpreterProxy.isBytes(f2));
	interpreterProxy.success(interpreterProxy.isBytes(f1));
	interpreterProxy.success((CLASSOF(prod)) === (interpreterProxy.classLargePositiveInteger()));
	interpreterProxy.success((CLASSOF(f2)) === (interpreterProxy.classLargePositiveInteger()));
	interpreterProxy.success((CLASSOF(f1)) === (interpreterProxy.classLargePositiveInteger()));
	if (interpreterProxy.failed()) {
		return null;
	}
	prodLen = SIZEOF(prod);
	f1Len = SIZEOF(f1);
	f2Len = SIZEOF(f2);
	interpreterProxy.success(prodLen === (f1Len + f2Len));
	if (interpreterProxy.failed()) {
		return null;
	}
	prodPtr = prod.bytes;
	f2Ptr = f2.bytes;
	f1Ptr = f1.bytes;
	for (i = 0; i <= (f1Len - 1); i++) {
		if (((digit = f1Ptr[i])) !== 0) {
			carry = 0;

			/* Loop invariants: 0 <= carry <= 16rFF, k = i + j - 1 */

			k = i;
			for (j = 0; j <= (f2Len - 1); j++) {
				sum = (((f2Ptr[j]) * digit) + (prodPtr[k])) + carry;
				carry = sum >>> 8;
				prodPtr[k] = (sum & 255);
				++k;
			}
			prodPtr[k] = carry;
		}
	}
	interpreterProxy.pop(3);
}


/*	Expand a 64 byte ByteArray (the first argument) into and an Bitmap of 80 32-bit words (the second argument). When reading a 32-bit integer from the ByteArray, consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering). */

function primitiveExpandBlock() {
	var buf;
	var bytePtr;
	var expanded;
	var i;
	var src;
	var v;
	var wordPtr;

	expanded = interpreterProxy.stackObjectValue(0);
	buf = interpreterProxy.stackObjectValue(1);
	interpreterProxy.success(interpreterProxy.isWords(expanded));
	interpreterProxy.success(interpreterProxy.isBytes(buf));
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success((SIZEOF(expanded)) === 80);
	interpreterProxy.success((SIZEOF(buf)) === 64);
	if (interpreterProxy.failed()) {
		return null;
	}
	wordPtr = expanded.words;
	bytePtr = buf.bytes;
	src = 0;
	for (i = 0; i <= 15; i++) {
		v = ((((bytePtr[src]) << 24) + ((bytePtr[src + 1]) << 16)) + ((bytePtr[src + 2]) << 8)) + (bytePtr[src + 3]);
		wordPtr[i] = v;
		src += 4;
	}
	for (i = 16; i <= 79; i++) {
		v = (((wordPtr[i - 3]) ^ (wordPtr[i - 8])) ^ (wordPtr[i - 14])) ^ (wordPtr[i - 16]);
		v = leftRotateby(v, 1);
		wordPtr[i] = v;
	}
	interpreterProxy.pop(2);
}


/*	Answer true if the secure hash primitive is implemented. */

function primitiveHasSecureHashPrimitive() {
	interpreterProxy.pop(1);
	interpreterProxy.pushBool(true);
}


/*	Hash a Bitmap of 80 32-bit words (the first argument), using the given state (the second argument). */

function primitiveHashBlock() {
	var a;
	var b;
	var buf;
	var bufPtr;
	var c;
	var d;
	var e;
	var i;
	var state;
	var statePtr;
	var tmp;

	state = interpreterProxy.stackObjectValue(0);
	buf = interpreterProxy.stackObjectValue(1);
	interpreterProxy.success(interpreterProxy.isWords(state));
	interpreterProxy.success(interpreterProxy.isWords(buf));
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success((SIZEOF(state)) === 5);
	interpreterProxy.success((SIZEOF(buf)) === 80);
	if (interpreterProxy.failed()) {
		return null;
	}
	statePtr = state.words;
	bufPtr = buf.words;
	a = statePtr[0];
	b = statePtr[1];
	c = statePtr[2];
	d = statePtr[3];
	e = statePtr[4];
	for (i = 0; i <= 19; i++) {
		tmp = (((1518500249 + ((b & c) | ((~b) & d))) + (leftRotateby(a, 5))) + e) + (bufPtr[i]);
		e = d;
		d = c;
		c = leftRotateby(b, 30);
		b = a;
		a = tmp;
	}
	for (i = 20; i <= 39; i++) {
		tmp = (((1859775393 + ((b ^ c) ^ d)) + (leftRotateby(a, 5))) + e) + (bufPtr[i]);
		e = d;
		d = c;
		c = leftRotateby(b, 30);
		b = a;
		a = tmp;
	}
	for (i = 40; i <= 59; i++) {
		tmp = (((2400959708 + (((b & c) | (b & d)) | (c & d))) + (leftRotateby(a, 5))) + e) + (bufPtr[i]);
		e = d;
		d = c;
		c = leftRotateby(b, 30);
		b = a;
		a = tmp;
	}
	for (i = 60; i <= 79; i++) {
		tmp = (((3395469782 + ((b ^ c) ^ d)) + (leftRotateby(a, 5))) + e) + (bufPtr[i]);
		e = d;
		d = c;
		c = leftRotateby(b, 30);
		b = a;
		a = tmp;
	}
	statePtr[0] = ((statePtr[0]) + a);
	statePtr[1] = ((statePtr[1]) + b);
	statePtr[2] = ((statePtr[2]) + c);
	statePtr[3] = ((statePtr[3]) + d);
	statePtr[4] = ((statePtr[4]) + e);
	interpreterProxy.pop(2);
}


/*	Called with one LargePositiveInteger argument. Answer the index of the top-most non-zero digit. */

function primitiveHighestNonZeroDigitIndex() {
	var arg;
	var bigIntPtr;
	var i;

	arg = interpreterProxy.stackObjectValue(0);
	interpreterProxy.success((CLASSOF(arg)) === (interpreterProxy.classLargePositiveInteger()));
	if (interpreterProxy.failed()) {
		return null;
	}
	bigIntPtr = arg.bytes;
	i = SIZEOF(arg);
	while ((i > 0) && ((bigIntPtr[(--i)]) === 0)) {
	}
	interpreterProxy.pop(1);
	interpreterProxy.pushInteger(i + 1);
}


/*	Note: This is coded so that is can be run from Squeak. */

function setInterpreter(anInterpreter) {
	var ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy.majorVersion() == VM_PROXY_MAJOR;
	if (ok === false) {
		return false;
	}
	ok = interpreterProxy.minorVersion() >= VM_PROXY_MINOR;
	return ok;
}


/*	Multiply the divisor by the given digit (an integer in the range 0..255), shift it left by the given number of digits, and subtract the result from the current remainder. Answer true if there is an excess borrow, indicating that digit was one too large. (This case is quite rare.) */

function subtractDivisorMultipliedByDigitdigitShift(digit, digitShift) {
	var borrow;
	var i;
	var prod;
	var rIndex;
	var resultDigit;

	borrow = 0;
	rIndex = digitShift + 1;
	for (i = 1; i <= divisorDigitCount; i++) {
		prod = ((dsaDivisor[i]) * digit) + borrow;
		borrow = prod >>> 8;
		resultDigit = (dsaRemainder[rIndex]) - (prod & 255);
		if (resultDigit < 0) {

			/* borrow from the next digit */

			resultDigit += 256;
			++borrow;
		}
		dsaRemainder[rIndex] = resultDigit;
		++rIndex;
	}
	if (borrow === 0) {
		return false;
	}
	resultDigit = (dsaRemainder[rIndex]) - borrow;
	if (resultDigit < 0) {

		/* digit was too large (this case is quite rare) */

		dsaRemainder[rIndex] = (resultDigit + 256);
		return true;
	} else {
		dsaRemainder[rIndex] = resultDigit;
		return false;
	}
}


Squeak.registerExternalModule("DSAPrims", {
	primitiveExpandBlock: primitiveExpandBlock,
	primitiveBigDivide: primitiveBigDivide,
	primitiveHasSecureHashPrimitive: primitiveHasSecureHashPrimitive,
	primitiveHashBlock: primitiveHashBlock,
	primitiveBigMultiply: primitiveBigMultiply,
	setInterpreter: setInterpreter,
	getModuleName: getModuleName,
	primitiveHighestNonZeroDigitIndex: primitiveHighestNonZeroDigitIndex,
});

}); // end of module
