/* Smalltalk from Squeak4.5 with VMMaker 4.13.6 translated as JS source on 3 November 2014 1:52:21 pm */
/* Automatically generated by
	JSPluginCodeGenerator VMMakerJS-bf.15 uuid: fd4e10f2-3773-4e80-8bb5-c4b471a014e5
   from
	KedamaPlugin Kedama-Plugins-yo.1 uuid: 3fc7d691-0149-ba4d-a339-5d27cd44a2f8
 */

(function KedamaPlugin() {
"use strict";

var VM_PROXY_MAJOR = 1;
var VM_PROXY_MINOR = 11;

/*** Functions ***/
function CLASSOF(obj) { return typeof obj === "number" ? interpreterProxy.classSmallInteger() : obj.sqClass }
function SIZEOF(obj) { return obj.pointers ? obj.pointers.length : obj.words ? obj.words.length : obj.bytes ? obj.bytes.length : 0 }
function BYTESIZEOF(obj) { return obj.bytes ? obj.bytes.length : obj.words ? obj.words.length * 4 : 0 }
function DIV(a, b) { return Math.floor(a / b) | 0; }   // integer division
function MOD(a, b) { return a - DIV(a, b) * b | 0; }   // signed modulus
function SHL(a, b) { return b > 31 ? 0 : a << b; }     // fix JS shift
function SHR(a, b) { return b > 31 ? 0 : a >>> b; }    // fix JS shift
function SHIFT(a, b) { return b < 0 ? (b < -31 ? 0 : a >>> (0-b) ) : (b > 31 ? 0 : a << b); }

/*** Variables ***/
var interpreterProxy = null;
var kedamaRandomSeed = 0;
var moduleName = "KedamaPlugin 3 November 2014 (e)";
var randA = 0;
var randM = 0;
var randQ = 0;
var randR = 0;


function degreesFromXy(x, y) {
	var tanVal;
	var theta;

	/* inline: true */;
	if (x === 0.0) {
		if (y >= 0.0) {
			return 90.0;
		} else {
			return 270.0;
		}
	} else {
		tanVal = y / x;
		theta = Math.atan(tanVal);
		if (x >= 0.0) {
			if (y >= 0.0) {
				return theta / 0.0174532925199433;
			} else {
				return 360.0 + (theta / 0.0174532925199433);
			}
		} else {
			return 180.0 + (theta / 0.0174532925199433);
		}
	}
	return 0.0;
}

function degreesToRadians(degrees) {
	var deg;
	var headingRadians;
	var q;

	/* inline: true */;
	deg = 90.0 - degrees;
	q = deg / 360.0|0;
	if (deg < 0.0) {
		--q;
	}
	headingRadians = (deg - (q * 360.0)) * 0.0174532925199433;
	return headingRadians;
}

function drawTurtlesInArray() {
	var bitsIndex;
	var colorArray;
	var colorOop;
	var destBits;
	var destHeight;
	var destOop;
	var destWidth;
	var i;
	var size;
	var visible;
	var visibleArray;
	var visibleOop;
	var x;
	var xArray;
	var xOop;
	var y;
	var yArray;
	var yOop;

	/* inline: true */;
	visibleOop = interpreterProxy.stackValue(0);
	colorOop = interpreterProxy.stackValue(1);
	yOop = interpreterProxy.stackValue(2);
	xOop = interpreterProxy.stackValue(3);
	destHeight = interpreterProxy.stackIntegerValue(4);
	destWidth = interpreterProxy.stackIntegerValue(5);
	destOop = interpreterProxy.stackValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(destOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(colorOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isBytes(visibleOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if ((destHeight * destWidth) !== SIZEOF(destOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xOop);
	if (SIZEOF(yOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(colorOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(visibleOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xOop.wordsAsFloat32Array();
	yArray = yOop.wordsAsFloat32Array();
	colorArray = colorOop.words;
	visibleArray = visibleOop.bytes;
	destBits = destOop.words;
	for (i = 0; i <= (size - 1); i++) {
		x = (xArray[i]|0);
		;
		y = (yArray[i]|0);
		;
		visible = visibleArray[i];
		if ((visible !== 0) && (((x >= 0) && (y >= 0)) && ((x < destWidth) && (y < destHeight)))) {
			bitsIndex = (y * destWidth) + x;
			destBits[bitsIndex] = colorArray[i];
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(7);
}

function getHeadingArrayInto() {
	var heading;
	var headingArray;
	var headingOop;
	var i;
	var resultArray;
	var resultOop;
	var size;

	/* inline: true */;
	resultOop = interpreterProxy.stackValue(0);
	headingOop = interpreterProxy.stackValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(resultOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(headingOop);
	if (SIZEOF(resultOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	headingArray = headingOop.wordsAsFloat32Array();
	resultArray = resultOop.wordsAsFloat32Array();
	for (i = 0; i <= (size - 1); i++) {
		heading = headingArray[i];
		heading = heading / 0.0174532925199433;
		heading = 90.0 - heading;
		if (!(heading > 0.0)) {
			heading += 360.0;
		}
		resultArray[i] = heading;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(2);
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

function getModuleName() {
	return moduleName;
}

function getScalarHeading() {
	var heading;
	var headingArray;
	var headingOop;
	var index;

	/* inline: true */;
	headingOop = interpreterProxy.stackValue(0);
	index = interpreterProxy.stackIntegerValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) < index) {
		interpreterProxy.primitiveFail();
		return null;
	}
	headingArray = headingOop.wordsAsFloat32Array();
	heading = headingArray[index - 1];
	heading = radiansToDegrees(heading);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(3);
	interpreterProxy.pushFloat(heading);
}

function halt() {
	;
}

function initialiseModule() {
	kedamaRandomSeed = 17;

	/*  magic constant =      16807  */

	randA = 16807;

	/*  magic constant = 2147483647  */

	randM = 2147483647;
	randQ = DIV(randM, randA);
	randR = MOD(randM, randA);
}

function kedamaRandom2(range) {
	var hi;
	var lo;
	var r;
	var v;
	var val;

	/* inline: true */;
	if (range < 0) {
		r = 0 - range;
	} else {
		r = range;
	}
	hi = DIV(kedamaRandomSeed, randQ);
	lo = MOD(kedamaRandomSeed, randQ);
	kedamaRandomSeed = (randA * lo) - (randR * hi);
	v = kedamaRandomSeed & 65535;
	val = (v * (r + 1)) >>> 16;
	if (range < 0) {
		return 0 - val;
	} else {
		return val;
	}
}

function kedamaSetRandomSeed() {
	var seed;

	/* inline: true */;
	seed = interpreterProxy.stackIntegerValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	kedamaRandomSeed = seed & 65536;
	interpreterProxy.pop(1);
}

function makeMask() {
	var alpha;
	var dOrigin;
	var data;
	var dataBits;
	var dataSize;
	var highMask;
	var i;
	var mOrigin;
	var maskBits;
	var maskSize;
	var pixel;
	var shiftAmount;

	/* inline: true */;
	shiftAmount = interpreterProxy.stackIntegerValue(0);
	pixel = interpreterProxy.stackIntegerValue(1);
	maskBits = interpreterProxy.stackValue(2);
	dataBits = interpreterProxy.stackValue(3);
	if (interpreterProxy.failed()) {
		return null;
	}
	dataSize = SIZEOF(dataBits);
	maskSize = SIZEOF(maskBits);
	if (dataSize !== maskSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (shiftAmount < -32) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (shiftAmount > 8) {
		interpreterProxy.primitiveFail();
		return null;
	}
	dOrigin = dataBits.words;
	mOrigin = maskBits.words;
	highMask = 4278190080;
	for (i = 0; i <= (dataSize - 1); i++) {
		data = dOrigin[i];
		alpha = SHIFT(data, shiftAmount);
		if (alpha > 255) {
			alpha = 255;
		}
		if (alpha < 0) {
			alpha = 0;
		}
		mOrigin[i] = (((alpha << 24) & highMask) | pixel);
	}
	interpreterProxy.pop(4);
}

function makeMaskLog() {
	var alpha;
	var dOrigin;
	var data;
	var dataBits;
	var dataSize;
	var highMask;
	var i;
	var mOrigin;
	var maskBits;
	var maskSize;
	var max;
	var maxFirst;
	var maxLog;
	var maxOop;
	var pixel;

	/* inline: true */;
	maxOop = interpreterProxy.stackValue(0);
	pixel = interpreterProxy.stackIntegerValue(1);
	maskBits = interpreterProxy.stackValue(2);
	dataBits = interpreterProxy.stackValue(3);
	if (interpreterProxy.failed()) {
		return null;
	}
	maxFirst = maxOop.words;
	max = maxFirst[0];
	if (interpreterProxy.failed()) {
		return null;
	}
	maxLog = Math.log(max);
	dataSize = SIZEOF(dataBits);
	maskSize = SIZEOF(maskBits);
	if (dataSize !== maskSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	dOrigin = dataBits.words;
	mOrigin = maskBits.words;
	highMask = 4278190080;
	for (i = 0; i <= (dataSize - 1); i++) {
		data = dOrigin[i];
		if (data === 0) {
			alpha = 0;
		} else {
			alpha = (((255.0 / maxLog) * Math.log(data))|0);
		}
		if (alpha > 255) {
			alpha = 255;
		}
		mOrigin[i] = (((alpha << 24) & highMask) | pixel);
	}
	interpreterProxy.pop(4);
}

function makeTurtlesMap() {
	var height;
	var index;
	var map;
	var mapIndex;
	var mapOop;
	var size;
	var whoArray;
	var whoOop;
	var width;
	var x;
	var xArray;
	var xOop;
	var y;
	var yArray;
	var yOop;

	/* inline: true */;
	height = interpreterProxy.stackIntegerValue(0);
	width = interpreterProxy.stackIntegerValue(1);
	yOop = interpreterProxy.stackValue(2);
	xOop = interpreterProxy.stackValue(3);
	whoOop = interpreterProxy.stackValue(4);
	mapOop = interpreterProxy.stackValue(5);
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(whoOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(mapOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(whoOop);
	if (SIZEOF(xOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(yOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(mapOop) !== (height * width)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xOop.wordsAsFloat32Array();
	yArray = yOop.wordsAsFloat32Array();
	whoArray = whoOop.words;
	map = mapOop.words;
	for (index = 0; index <= ((height * width) - 1); index++) {
		map[index] = 0;
	}
	for (index = 0; index <= (size - 1); index++) {
		x = xArray[index];
		y = yArray[index];
		mapIndex = (width * y) + x;
		if ((mapIndex >= 0) && (mapIndex < (height * width))) {
			map[mapIndex] = whoArray[index];
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
}

function primPixelAtXY() {
	var bits;
	var bitsOop;
	var height;
	var index;
	var ret;
	var width;
	var x;
	var xPos;
	var y;
	var yPos;

	/* inline: true */;
	height = interpreterProxy.stackIntegerValue(0);
	width = interpreterProxy.stackIntegerValue(1);
	yPos = interpreterProxy.stackFloatValue(2);
	xPos = interpreterProxy.stackFloatValue(3);
	bitsOop = interpreterProxy.stackValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(bitsOop) !== (height * width)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	x = xPos|0;
	y = yPos|0;
	bits = bitsOop.words;
	if ((((x >= 0) && (x < width)) && (y >= 0)) && (y < height)) {
		index = (y * width) + x;
		ret = bits[index];
	} else {
		ret = 0;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
	interpreterProxy.pushInteger(ret);
}

function primPixelAtXYPut() {
	var bits;
	var bitsOop;
	var height;
	var index;
	var v;
	var value;
	var width;
	var x;
	var xPos;
	var y;
	var yPos;

	/* inline: true */;
	height = interpreterProxy.stackIntegerValue(0);
	width = interpreterProxy.stackIntegerValue(1);
	value = interpreterProxy.stackIntegerValue(2);
	yPos = interpreterProxy.stackFloatValue(3);
	xPos = interpreterProxy.stackFloatValue(4);
	bitsOop = interpreterProxy.stackValue(5);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(bitsOop) !== (height * width)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	x = xPos|0;
	y = yPos|0;
	v = value;
	if (v > 1073741823) {
		v = 1073741823;
	}
	if (v < 0) {
		v = 0;
	}
	bits = bitsOop.words;
	if ((((x >= 0) && (x < width)) && (y >= 0)) && (y < height)) {
		index = (y * width) + x;
		bits[index] = v;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
}

function primPixelsAtXY() {
	var bits;
	var bitsHeight;
	var bitsIndex;
	var bitsOop;
	var bitsWidth;
	var destWords;
	var destWordsOop;
	var i;
	var size;
	var x;
	var xArray;
	var xArrayOop;
	var y;
	var yArray;
	var yArrayOop;

	/* inline: true */;
	destWordsOop = interpreterProxy.stackValue(0);
	bitsHeight = interpreterProxy.stackIntegerValue(1);
	bitsWidth = interpreterProxy.stackIntegerValue(2);
	bitsOop = interpreterProxy.stackValue(3);
	yArrayOop = interpreterProxy.stackValue(4);
	xArrayOop = interpreterProxy.stackValue(5);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(destWordsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if ((bitsHeight * bitsWidth) !== SIZEOF(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xArrayOop);
	if (SIZEOF(yArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(destWordsOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xArrayOop.wordsAsFloat32Array();
	yArray = yArrayOop.wordsAsFloat32Array();
	destWords = destWordsOop.words;
	bits = bitsOop.words;
	for (i = 0; i <= (size - 1); i++) {
		x = (xArray[i]|0);
		;
		y = (yArray[i]|0);
		;
		if (((x >= 0) && (y >= 0)) && ((x < bitsWidth) && (y < bitsHeight))) {
			bitsIndex = (y * bitsWidth) + x;
			destWords[i] = bits[bitsIndex];
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
}

function primScalarForward() {
	var bottomEdgeMode;
	var destHeight;
	var destWidth;
	var dist;
	var headingArray;
	var headingOop;
	var i;
	var index;
	var leftEdgeMode;
	var newX;
	var newY;
	var rightEdgeMode;
	var size;
	var topEdgeMode;
	var val;
	var xArray;
	var xOop;
	var yArray;
	var yOop;

	/* inline: true */;
	bottomEdgeMode = interpreterProxy.stackIntegerValue(0);
	topEdgeMode = interpreterProxy.stackIntegerValue(1);
	rightEdgeMode = interpreterProxy.stackIntegerValue(2);
	leftEdgeMode = interpreterProxy.stackIntegerValue(3);
	destHeight = interpreterProxy.stackFloatValue(4);
	destWidth = interpreterProxy.stackFloatValue(5);
	val = interpreterProxy.stackFloatValue(6);
	headingOop = interpreterProxy.stackValue(7);
	yOop = interpreterProxy.stackValue(8);
	xOop = interpreterProxy.stackValue(9);
	index = interpreterProxy.stackIntegerValue(10);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xOop);
	if (SIZEOF(yOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xOop.wordsAsFloat32Array();
	yArray = yOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	dist = val;
	i = index - 1;
	newX = xArray[i] + (dist * Math.cos(headingArray[i]));
	newY = yArray[i] - (dist * Math.sin(headingArray[i]));
	scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(i, xArray, headingArray, newX, destWidth, leftEdgeMode, rightEdgeMode);
	scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(i, yArray, headingArray, newY, destHeight, topEdgeMode, bottomEdgeMode);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(11);
}

function primSetPixelsAtXY() {
	var bits;
	var bitsHeight;
	var bitsIndex;
	var bitsOop;
	var bitsWidth;
	var i;
	var intValue;
	var isValueInt;
	var size;
	var value;
	var valueOop;
	var wordsValue;
	var x;
	var xArray;
	var xArrayOop;
	var y;
	var yArray;
	var yArrayOop;

	/* inline: true */;
	valueOop = interpreterProxy.stackValue(0);
	bitsHeight = interpreterProxy.stackIntegerValue(1);
	bitsWidth = interpreterProxy.stackIntegerValue(2);
	bitsOop = interpreterProxy.stackValue(3);
	yArrayOop = interpreterProxy.stackValue(4);
	xArrayOop = interpreterProxy.stackValue(5);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(xArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if ((bitsHeight * bitsWidth) !== SIZEOF(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xArrayOop);
	if (SIZEOF(yArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	isValueInt = typeof valueOop === "number";
	if (isValueInt) {
		intValue = valueOop;
	}
	if (!isValueInt) {
		if (!interpreterProxy.isMemberOf(valueOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
		if (SIZEOF(valueOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	xArray = xArrayOop.wordsAsFloat32Array();
	yArray = yArrayOop.wordsAsFloat32Array();
	if (!isValueInt) {
		wordsValue = valueOop.words;
	}
	bits = bitsOop.words;
	if (isValueInt) {
		value = intValue;
	}
	for (i = 0; i <= (size - 1); i++) {
		x = (xArray[i]|0);
		;
		y = (yArray[i]|0);
		;
		if (((x >= 0) && (y >= 0)) && ((x < bitsWidth) && (y < bitsHeight))) {
			bitsIndex = (y * bitsWidth) + x;
			if (!isValueInt) {
				value = wordsValue[i];
			}
			bits[bitsIndex] = value;
		}
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
}

function primTurtlesForward() {
	var bottomEdgeMode;
	var destHeight;
	var destWidth;
	var dist;
	var headingArray;
	var headingOop;
	var i;
	var isValVector;
	var leftEdgeMode;
	var newX;
	var newY;
	var rightEdgeMode;
	var size;
	var topEdgeMode;
	var val;
	var valArray;
	var valOop;
	var xArray;
	var xOop;
	var yArray;
	var yOop;

	/* inline: true */;
	bottomEdgeMode = interpreterProxy.stackIntegerValue(0);
	topEdgeMode = interpreterProxy.stackIntegerValue(1);
	rightEdgeMode = interpreterProxy.stackIntegerValue(2);
	leftEdgeMode = interpreterProxy.stackIntegerValue(3);
	destHeight = interpreterProxy.stackFloatValue(4);
	destWidth = interpreterProxy.stackFloatValue(5);
	valOop = interpreterProxy.stackValue(6);
	headingOop = interpreterProxy.stackValue(7);
	yOop = interpreterProxy.stackValue(8);
	xOop = interpreterProxy.stackValue(9);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (valOop.isFloat) {
		isValVector = false;
	} else {
		if (interpreterProxy.isWords(valOop)) {
			isValVector = true;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	size = SIZEOF(xOop);
	if (SIZEOF(yOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (isValVector) {
		if (SIZEOF(valOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	xArray = xOop.wordsAsFloat32Array();
	yArray = yOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	if (isValVector) {
		valArray = valOop.wordsAsFloat32Array();
	} else {
		val = interpreterProxy.floatValueOf(valOop);
	}
	for (i = 0; i <= (size - 1); i++) {
		if (isValVector) {
			dist = valArray[i];
		} else {
			dist = val;
		}
		newX = xArray[i] + (dist * Math.cos(headingArray[i]));
		newY = yArray[i] - (dist * Math.sin(headingArray[i]));
		scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(i, xArray, headingArray, newX, destWidth, leftEdgeMode, rightEdgeMode);
		scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(i, yArray, headingArray, newY, destHeight, topEdgeMode, bottomEdgeMode);
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(10);
}

function primUpHill() {
	var bits;
	var bitsOop;
	var endX;
	var endY;
	var height;
	var maxVal;
	var maxValX;
	var maxValY;
	var ret;
	var rowOffset;
	var sniffRange;
	var startX;
	var startY;
	var tH;
	var tX;
	var tY;
	var thisVal;
	var turtleX;
	var turtleY;
	var width;
	var x;
	var y;

	/* inline: true */;
	sniffRange = interpreterProxy.stackIntegerValue(0);
	height = interpreterProxy.stackIntegerValue(1);
	width = interpreterProxy.stackIntegerValue(2);
	bitsOop = interpreterProxy.stackValue(3);
	tH = interpreterProxy.stackFloatValue(4);
	tY = interpreterProxy.stackFloatValue(5);
	tX = interpreterProxy.stackFloatValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(bitsOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(bitsOop) !== (height * width)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	bits = bitsOop.words;
	turtleX = tX;
	turtleY = tY;
	turtleX = Math.max(turtleX, 0);
	turtleY = Math.max(turtleY, 0);
	turtleX = Math.min(turtleX, (width - 1));
	turtleY = Math.min(turtleY, (height - 1));
	startX = Math.max((turtleX - sniffRange), 0);
	endX = Math.min((turtleX + sniffRange), (width - 1));
	startY = Math.max((turtleY - sniffRange), 0);
	endY = Math.min((turtleY + sniffRange), (height - 1));
	maxVal = bits[(turtleY * width) + turtleX];
	maxValX = -1;
	for (y = startY; y <= endY; y++) {
		rowOffset = y * width;
		for (x = startX; x <= endX; x++) {
			thisVal = bits[rowOffset + x];
			if (thisVal > maxVal) {
				maxValX = x;
				maxValY = y;
				maxVal = thisVal;
			}
		}
	}
	if (-1 === maxValX) {
		ret = radiansToDegrees(tH);
	} else {
		ret = degreesFromXy((maxValX - turtleX), (maxValY - turtleY)) + 90.0|0;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(8);
	interpreterProxy.pushFloat(ret);
}

function primitiveAddArrays() {
	var argOop;
	var floatsArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgWords && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] + wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] + floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] + wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] + floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveAddScalar() {
	var argOop;
	var floatArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgInt && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] + intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] + floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] + intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] + floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveDivArrays() {
	var argOop;
	var floatsArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgWords && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] / wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] / floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] / wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] / floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveDivScalar() {
	var argOop;
	var floatArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgInt && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (DIV(wordsRcvr[i], intArg));
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] / floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] / intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] / floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveMulArrays() {
	var argOop;
	var floatsArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgWords && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] * wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] * floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] * wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] * floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveMulScalar() {
	var argOop;
	var floatArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgInt && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] * intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] * floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] * intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] * floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveSubArrays() {
	var argOop;
	var floatsArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var isArgWords;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsArg;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackObjectValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(argOop));
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(argOop);
	interpreterProxy.success(length === SIZEOF(rcvrOop));
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgWords = interpreterProxy.isMemberOf(argOop, "WordArray");
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgWords && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgWords) {
			wordsRcvr = rcvrOop.words;
			wordsArg = argOop.words;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] - wordsArg[i]);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] - floatsArg[i]);
			}
		}
	} else {
		if (isArgWords) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			wordsArg = argOop.words;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] - wordsArg[i]);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatsArg = argOop.wordsAsFloat32Array();
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] - floatsArg[i]);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function primitiveSubScalar() {
	var argOop;
	var floatArg;
	var floatsRcvr;
	var floatsResult;
	var i;
	var intArg;
	var isArgInt;
	var isRcvrWords;
	var length;
	var rcvrOop;
	var resultOop;
	var wordsRcvr;
	var wordsResult;

	/* inline: true */;
	resultOop = interpreterProxy.stackObjectValue(0);
	argOop = interpreterProxy.stackValue(1);
	rcvrOop = interpreterProxy.stackObjectValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.success(interpreterProxy.isWords(rcvrOop));
	interpreterProxy.success(interpreterProxy.isWords(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	length = SIZEOF(rcvrOop);
	interpreterProxy.success(length === SIZEOF(resultOop));
	if (interpreterProxy.failed()) {
		return null;
	}
	isArgInt = typeof argOop === "number";
	isRcvrWords = interpreterProxy.isMemberOf(rcvrOop, "WordArray");
	if (isArgInt && isRcvrWords) {
		if (!interpreterProxy.isMemberOf(resultOop, "WordArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (!interpreterProxy.isMemberOf(resultOop, "KedamaFloatArray")) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	if (isRcvrWords) {
		if (isArgInt) {
			wordsRcvr = rcvrOop.words;
			intArg = argOop;
			wordsResult = resultOop.words;
			for (i = 0; i <= (length - 1); i++) {
				wordsResult[i] = (wordsRcvr[i] - intArg);
			}
		} else {
			wordsRcvr = rcvrOop.words;
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (wordsRcvr[i] - floatArg);
			}
		}
	} else {
		if (isArgInt) {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			intArg = argOop;
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] - intArg);
			}
		} else {
			floatsRcvr = rcvrOop.wordsAsFloat32Array();
			floatArg = interpreterProxy.floatValueOf(argOop);
			floatsResult = resultOop.wordsAsFloat32Array();
			for (i = 0; i <= (length - 1); i++) {
				floatsResult[i] = (floatsRcvr[i] - floatArg);
			}
		}
	}
	interpreterProxy.pop(4);
	interpreterProxy.push(resultOop);
}

function radiansToDegrees(radians) {
	var deg;
	var degrees;

	/* inline: true */;
	degrees = radians / 0.0174532925199433;
	deg = 90.0 - degrees;
	if (!(deg > 0.0)) {
		deg += 360.0;
	}
	return deg;
}

function randomIntoFloatArray() {
	var factor;
	var floatArray;
	var floatArrayOop;
	var from;
	var index;
	var range;
	var size;
	var to;

	/* inline: true */;
	factor = interpreterProxy.stackFloatValue(0);
	floatArrayOop = interpreterProxy.stackValue(1);
	to = interpreterProxy.stackIntegerValue(2);
	from = interpreterProxy.stackIntegerValue(3);
	range = interpreterProxy.stackIntegerValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(floatArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(floatArrayOop);
	if (!((size >= to) && ((from >= 1) && (to >= from)))) {
		interpreterProxy.primitiveFail();
		return null;
	}
	floatArray = floatArrayOop.wordsAsFloat32Array();
	if (interpreterProxy.failed()) {
		return null;
	}
	for (index = from; index <= to; index++) {
		floatArray[index - 1] = (kedamaRandom2(range) * factor);
	}
	interpreterProxy.pop(5);
}

function randomIntoIntegerArray() {
	var factor;
	var from;
	var index;
	var integerArray;
	var integerArrayOop;
	var range;
	var size;
	var to;

	/* inline: true */;
	factor = interpreterProxy.stackFloatValue(0);
	integerArrayOop = interpreterProxy.stackValue(1);
	to = interpreterProxy.stackIntegerValue(2);
	from = interpreterProxy.stackIntegerValue(3);
	range = interpreterProxy.stackIntegerValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(integerArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(integerArrayOop);
	if (!((size >= to) && ((from >= 1) && (to >= from)))) {
		interpreterProxy.primitiveFail();
		return null;
	}
	integerArray = integerArrayOop.words;
	if (interpreterProxy.failed()) {
		return null;
	}
	for (index = from; index <= to; index++) {
		integerArray[index - 1] = ((kedamaRandom2(range) * factor)|0);
	}
	interpreterProxy.pop(5);
}

function randomRange() {
	var range;
	var ret;

	/* inline: true */;
	range = interpreterProxy.stackIntegerValue(0);
	if (interpreterProxy.failed()) {
		return null;
	}
	ret = kedamaRandom2(range);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(2);
	interpreterProxy.pushInteger(ret);
}

function scalarGetAngleTo() {
	var fromX;
	var fromY;
	var r;
	var toX;
	var toY;
	var x;
	var y;

	/* inline: true */;
	fromY = interpreterProxy.stackFloatValue(0);
	fromX = interpreterProxy.stackFloatValue(1);
	toY = interpreterProxy.stackFloatValue(2);
	toX = interpreterProxy.stackFloatValue(3);
	if (interpreterProxy.failed()) {
		return null;
	}
	x = toX - fromX;
	y = toY - fromY;
	r = degreesFromXy(x, y);
	r += 90.0;
	if (r > 360.0) {
		r -= 360.0;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(5);
	interpreterProxy.pushFloat(r);
}

function scalarGetDistanceTo() {
	var fromX;
	var fromY;
	var r;
	var toX;
	var toY;
	var x;
	var y;

	/* inline: true */;
	fromY = interpreterProxy.stackFloatValue(0);
	fromX = interpreterProxy.stackFloatValue(1);
	toY = interpreterProxy.stackFloatValue(2);
	toX = interpreterProxy.stackFloatValue(3);
	if (interpreterProxy.failed()) {
		return null;
	}
	x = fromX - toX;
	y = fromY - toY;
	r = Math.sqrt((x * x) + (y * y));
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(5);
	interpreterProxy.pushFloat(r);
}

function scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(index, xArray, headingArray, val, destWidth, leftEdgeMode, rightEdgeMode) {
	var headingRadians;
	var newX;

	/* inline: true */;
	newX = val;
	if (newX < 0.0) {
		if (leftEdgeMode === 1) {

			/* wrap */

			newX += destWidth;
		}
		if (leftEdgeMode === 2) {

			/* stick */

			newX = 0.0;
		}
		if (leftEdgeMode === 3) {

			/* bounce */

			newX = 0.0 - newX;
			headingRadians = headingArray[index];
			if (headingRadians < 3.141592653589793) {
				headingArray[index] = (3.141592653589793 - headingRadians);
			} else {
				headingArray[index] = (9.42477796076938 - headingRadians);
			}
		}
	}
	if (newX >= destWidth) {
		if (rightEdgeMode === 1) {
			newX -= destWidth;
		}
		if (rightEdgeMode === 2) {
			newX = destWidth - 1.0e-6;
		}
		if (rightEdgeMode === 3) {
			newX = (destWidth - 1.0e-6) - (newX - destWidth);
			headingRadians = headingArray[index];
			if (headingRadians < 3.141592653589793) {
				headingArray[index] = (3.141592653589793 - headingRadians);
			} else {
				headingArray[index] = (9.42477796076938 - headingRadians);
			}
		}
	}
	xArray[index] = newX;
}

function scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(index, yArray, headingArray, val, destHeight, topEdgeMode, bottomEdgeMode) {
	var newY;

	/* inline: true */;
	newY = val;
	if (newY < 0.0) {
		if (topEdgeMode === 1) {

			/* wrap */

			newY += destHeight;
		}
		if (topEdgeMode === 2) {

			/* stick */

			newY = 0.0;
		}
		if (topEdgeMode === 3) {

			/* bounce */

			newY = 0.0 - newY;
			headingArray[index] = (6.283185307179586 - headingArray[index]);
		}
	}
	if (newY >= destHeight) {
		if (bottomEdgeMode === 1) {
			newY -= destHeight;
		}
		if (bottomEdgeMode === 2) {
			newY = destHeight - 1.0e-6;
		}
		if (bottomEdgeMode === 3) {
			newY = (destHeight - 1.0e-6) - (newY - destHeight);
			headingArray[index] = (6.283185307179586 - headingArray[index]);
		}
	}
	yArray[index] = newY;
}

function setHeadingArrayFrom() {
	var heading;
	var headingArray;
	var headingOop;
	var i;
	var isValVector;
	var resultArray;
	var resultOop;
	var size;

	/* inline: true */;
	resultOop = interpreterProxy.stackValue(0);
	headingOop = interpreterProxy.stackValue(1);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(headingOop);
	if (resultOop.isFloat) {
		isValVector = false;
	} else {
		if (interpreterProxy.isWords(resultOop)) {
			if (SIZEOF(resultOop) !== size) {
				interpreterProxy.primitiveFail();
				return null;
			}
			isValVector = true;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	headingArray = headingOop.wordsAsFloat32Array();
	if (isValVector) {
		resultArray = resultOop.wordsAsFloat32Array();
	} else {
		heading = interpreterProxy.floatValueOf(resultOop);
		heading = degreesToRadians(heading);
	}
	for (i = 0; i <= (size - 1); i++) {
		if (isValVector) {
			heading = resultArray[i];
			heading = degreesToRadians(heading);
		}
		headingArray[i] = heading;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(2);
}


/*	Note: This is coded so that is can be run from Squeak. */

function setInterpreter(anInterpreter) {
	var ok;

	interpreterProxy = anInterpreter;
	ok = interpreterProxy.majorVersion() == VM_PROXY_MAJOR;
	if (ok === false) {
		return false;
	}
	ok = interpreterProxy.minorVersion() >= VM_PROXY_MINOR;
	return ok;
}

function setScalarHeading() {
	var heading;
	var headingArray;
	var headingOop;
	var index;

	/* inline: true */;
	heading = interpreterProxy.stackFloatValue(0);
	headingOop = interpreterProxy.stackValue(1);
	index = interpreterProxy.stackIntegerValue(2);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(headingOop) < index) {
		interpreterProxy.primitiveFail();
		return null;
	}
	headingArray = headingOop.wordsAsFloat32Array();
	headingArray[index - 1] = degreesToRadians(heading);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(3);
}

function shutdownModule() {
	return true;
}

function turtleScalarSetX() {
	var destWidth;
	var headingArray;
	var headingOop;
	var leftEdgeMode;
	var rightEdgeMode;
	var size;
	var val;
	var xArray;
	var xIndex;
	var xOop;

	/* inline: true */;
	rightEdgeMode = interpreterProxy.stackIntegerValue(0);
	leftEdgeMode = interpreterProxy.stackIntegerValue(1);
	destWidth = interpreterProxy.stackFloatValue(2);
	val = interpreterProxy.stackFloatValue(3);
	headingOop = interpreterProxy.stackValue(4);
	xIndex = interpreterProxy.stackIntegerValue(5);
	xOop = interpreterProxy.stackValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(xOop);
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	xArray = xOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(xIndex - 1, xArray, headingArray, val, destWidth, leftEdgeMode, rightEdgeMode);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(7);
}

function turtleScalarSetY() {
	var bottomEdgeMode;
	var destHeight;
	var headingArray;
	var headingOop;
	var size;
	var topEdgeMode;
	var val;
	var yArray;
	var yIndex;
	var yOop;

	/* inline: true */;
	bottomEdgeMode = interpreterProxy.stackIntegerValue(0);
	topEdgeMode = interpreterProxy.stackIntegerValue(1);
	destHeight = interpreterProxy.stackFloatValue(2);
	val = interpreterProxy.stackFloatValue(3);
	headingOop = interpreterProxy.stackValue(4);
	yIndex = interpreterProxy.stackIntegerValue(5);
	yOop = interpreterProxy.stackValue(6);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(yOop);
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	yArray = yOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(yIndex - 1, yArray, headingArray, val, destHeight, topEdgeMode, bottomEdgeMode);
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(7);
}

function turtlesSetX() {
	var destWidth;
	var headingArray;
	var headingOop;
	var i;
	var isValVector;
	var leftEdgeMode;
	var newX;
	var rightEdgeMode;
	var size;
	var val;
	var valArray;
	var valOop;
	var xArray;
	var xOop;

	/* inline: true */;
	rightEdgeMode = interpreterProxy.stackIntegerValue(0);
	leftEdgeMode = interpreterProxy.stackIntegerValue(1);
	destWidth = interpreterProxy.stackFloatValue(2);
	valOop = interpreterProxy.stackValue(3);
	headingOop = interpreterProxy.stackValue(4);
	xOop = interpreterProxy.stackValue(5);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(xOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (valOop.isFloat) {
		isValVector = false;
	} else {
		if (interpreterProxy.isWords(valOop)) {
			isValVector = true;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	size = SIZEOF(xOop);
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (isValVector) {
		if (SIZEOF(valOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	xArray = xOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	if (isValVector) {
		valArray = valOop.wordsAsFloat32Array();
	} else {
		val = interpreterProxy.floatValueOf(valOop);
	}
	for (i = 0; i <= (size - 1); i++) {
		if (isValVector) {
			newX = valArray[i];
		} else {
			newX = val;
		}
		scalarXAtxArrayheadingArrayvaluedestWidthleftEdgeModerightEdgeMode(i, xArray, headingArray, newX, destWidth, leftEdgeMode, rightEdgeMode);
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
}

function turtlesSetY() {
	var bottomEdgeMode;
	var destHeight;
	var headingArray;
	var headingOop;
	var i;
	var isValVector;
	var newY;
	var size;
	var topEdgeMode;
	var val;
	var valArray;
	var valOop;
	var yArray;
	var yOop;

	/* inline: true */;
	bottomEdgeMode = interpreterProxy.stackIntegerValue(0);
	topEdgeMode = interpreterProxy.stackIntegerValue(1);
	destHeight = interpreterProxy.stackFloatValue(2);
	valOop = interpreterProxy.stackValue(3);
	headingOop = interpreterProxy.stackValue(4);
	yOop = interpreterProxy.stackValue(5);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(yOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(headingOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (valOop.isFloat) {
		isValVector = false;
	} else {
		if (interpreterProxy.isWords(valOop)) {
			isValVector = true;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	size = SIZEOF(yOop);
	if (SIZEOF(headingOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (isValVector) {
		if (SIZEOF(valOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	yArray = yOop.wordsAsFloat32Array();
	headingArray = headingOop.wordsAsFloat32Array();
	if (isValVector) {
		valArray = valOop.wordsAsFloat32Array();
	} else {
		val = interpreterProxy.floatValueOf(valOop);
	}
	for (i = 0; i <= (size - 1); i++) {
		if (isValVector) {
			newY = valArray[i];
		} else {
			newY = val;
		}
		scalarYAtyArrayheadingArrayvaluedestHeighttopEdgeModebottomEdgeMode(i, yArray, headingArray, newY, destHeight, topEdgeMode, bottomEdgeMode);
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
}

function vectorGetAngleTo() {
	var index;
	var isVector;
	var pX;
	var pXOop;
	var pY;
	var pYOop;
	var ppx;
	var ppy;
	var r;
	var result;
	var resultOop;
	var size;
	var x;
	var xArray;
	var xArrayOop;
	var y;
	var yArray;
	var yArrayOop;

	/* inline: true */;
	resultOop = interpreterProxy.stackValue(0);
	yArrayOop = interpreterProxy.stackValue(1);
	xArrayOop = interpreterProxy.stackValue(2);
	pYOop = interpreterProxy.stackValue(3);
	pXOop = interpreterProxy.stackValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(resultOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(resultOop);
	if (size < 0) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(xArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(yArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (pXOop.isFloat) {
		if (pYOop.isFloat) {
			isVector = false;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (pYOop.isFloat) {
			interpreterProxy.primitiveFail();
			return null;
		} else {
			isVector = true;
		}
	}
	if (isVector) {
		if (SIZEOF(pXOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
		if (SIZEOF(pYOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	result = resultOop.wordsAsFloat32Array();
	xArray = xArrayOop.wordsAsFloat32Array();
	yArray = yArrayOop.wordsAsFloat32Array();
	if (isVector) {
		pX = pXOop.wordsAsFloat32Array();
		pY = pYOop.wordsAsFloat32Array();
	}
	if (!isVector) {
		ppx = interpreterProxy.floatValueOf(pXOop);
		ppy = interpreterProxy.floatValueOf(pYOop);
	}
	for (index = 0; index <= (size - 1); index++) {
		if (isVector) {
			ppx = pX[index];
			ppy = pY[index];
		}
		x = ppx - xArray[index];
		y = ppy - yArray[index];
		r = degreesFromXy(x, y);
		r += 90.0;
		if (r > 360.0) {
			r -= 360.0;
		}
		result[index] = r;
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
	interpreterProxy.push(resultOop);
}

function vectorGetDistanceTo() {
	var index;
	var isVector;
	var pX;
	var pXOop;
	var pY;
	var pYOop;
	var ppx;
	var ppy;
	var result;
	var resultOop;
	var size;
	var x;
	var xArray;
	var xArrayOop;
	var y;
	var yArray;
	var yArrayOop;

	/* inline: true */;
	resultOop = interpreterProxy.stackValue(0);
	yArrayOop = interpreterProxy.stackValue(1);
	xArrayOop = interpreterProxy.stackValue(2);
	pYOop = interpreterProxy.stackValue(3);
	pXOop = interpreterProxy.stackValue(4);
	if (interpreterProxy.failed()) {
		return null;
	}
	if (!interpreterProxy.isWords(resultOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(xArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (!interpreterProxy.isWords(yArrayOop)) {
		interpreterProxy.primitiveFail();
		return null;
	}
	size = SIZEOF(resultOop);
	if (size < 0) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(xArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (SIZEOF(yArrayOop) !== size) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (pXOop.isFloat) {
		if (pYOop.isFloat) {
			isVector = false;
		} else {
			interpreterProxy.primitiveFail();
			return null;
		}
	} else {
		if (pYOop.isFloat) {
			interpreterProxy.primitiveFail();
			return null;
		} else {
			isVector = true;
		}
	}
	if (isVector) {
		if (SIZEOF(pXOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
		if (SIZEOF(pYOop) !== size) {
			interpreterProxy.primitiveFail();
			return null;
		}
	}
	result = resultOop.wordsAsFloat32Array();
	xArray = xArrayOop.wordsAsFloat32Array();
	yArray = yArrayOop.wordsAsFloat32Array();
	if (isVector) {
		pX = pXOop.wordsAsFloat32Array();
		pY = pYOop.wordsAsFloat32Array();
	}
	if (!isVector) {
		ppx = interpreterProxy.floatValueOf(pXOop);
		ppy = interpreterProxy.floatValueOf(pYOop);
	}
	for (index = 0; index <= (size - 1); index++) {
		if (isVector) {
			ppx = pX[index];
			ppy = pY[index];
		}
		x = ppx - xArray[index];
		y = ppy - yArray[index];
		result[index] = Math.sqrt((x * x) + (y * y));
	}
	if (interpreterProxy.failed()) {
		return null;
	}
	interpreterProxy.pop(6);
	interpreterProxy.push(resultOop);
}

function zoomBitmap() {
	var bit;
	var dOrigin;
	var dst;
	var dstIndex;
	var dstSize;
	var dummy;
	var sHeight;
	var sOrigin;
	var sWidth;
	var src;
	var srcIndex;
	var srcOrigin;
	var srcSize;
	var sx;
	var sy;
	var xFactor;
	var y;
	var yFactor;

	/* inline: true */;
	yFactor = interpreterProxy.stackIntegerValue(0);
	xFactor = interpreterProxy.stackIntegerValue(1);
	sHeight = interpreterProxy.stackIntegerValue(2);
	sWidth = interpreterProxy.stackIntegerValue(3);
	dst = interpreterProxy.stackValue(4);
	src = interpreterProxy.stackValue(5);
	if (interpreterProxy.failed()) {
		return null;
	}
	srcSize = SIZEOF(src);
	dstSize = SIZEOF(dst);
	if ((sWidth * sHeight) !== srcSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	if (((srcSize * xFactor) * yFactor) !== dstSize) {
		interpreterProxy.primitiveFail();
		return null;
	}
	sOrigin = src.words;
	dOrigin = dst.words;
	srcIndex = 0;
	srcOrigin = 0;
	dstIndex = 0;
	for (sy = 0; sy <= (sHeight - 1); sy++) {
		for (y = 0; y <= (yFactor - 1); y++) {
			for (sx = 0; sx <= (sWidth - 1); sx++) {
				bit = sOrigin[srcIndex];
				++srcIndex;
				for (dummy = 0; dummy <= (xFactor - 1); dummy++) {
					dOrigin[dstIndex] = bit;
					++dstIndex;
				}
			}
			srcIndex = srcOrigin;
		}
		srcOrigin += sWidth;
		srcIndex = srcOrigin;
	}
	interpreterProxy.pop(6);
}


function registerPlugin() {
	if (typeof Squeak === "object" && Squeak.registerExternalModule) {
		Squeak.registerExternalModule("KedamaPlugin", {
			makeMaskLog: makeMaskLog,
			vectorGetDistanceTo: vectorGetDistanceTo,
			getScalarHeading: getScalarHeading,
			shutdownModule: shutdownModule,
			primitiveAddScalar: primitiveAddScalar,
			primSetPixelsAtXY: primSetPixelsAtXY,
			turtleScalarSetX: turtleScalarSetX,
			primPixelAtXY: primPixelAtXY,
			primUpHill: primUpHill,
			primScalarForward: primScalarForward,
			primitiveDivArrays: primitiveDivArrays,
			getModuleName: getModuleName,
			primitiveSubArrays: primitiveSubArrays,
			scalarGetAngleTo: scalarGetAngleTo,
			randomRange: randomRange,
			setInterpreter: setInterpreter,
			kedamaSetRandomSeed: kedamaSetRandomSeed,
			drawTurtlesInArray: drawTurtlesInArray,
			turtleScalarSetY: turtleScalarSetY,
			randomIntoIntegerArray: randomIntoIntegerArray,
			getHeadingArrayInto: getHeadingArrayInto,
			makeTurtlesMap: makeTurtlesMap,
			setHeadingArrayFrom: setHeadingArrayFrom,
			turtlesSetX: turtlesSetX,
			setScalarHeading: setScalarHeading,
			makeMask: makeMask,
			primitiveDivScalar: primitiveDivScalar,
			primitiveSubScalar: primitiveSubScalar,
			primPixelsAtXY: primPixelsAtXY,
			vectorGetAngleTo: vectorGetAngleTo,
			primitiveMulArrays: primitiveMulArrays,
			primPixelAtXYPut: primPixelAtXYPut,
			zoomBitmap: zoomBitmap,
			initialiseModule: initialiseModule,
			primitiveAddArrays: primitiveAddArrays,
			scalarGetDistanceTo: scalarGetDistanceTo,
			turtlesSetY: turtlesSetY,
			randomIntoFloatArray: randomIntoFloatArray,
			primTurtlesForward: primTurtlesForward,
			primitiveMulScalar: primitiveMulScalar,
		});
	} else self.setTimeout(registerPlugin, 100);
}

registerPlugin();

})(); // Register module/plugin
